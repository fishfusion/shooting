<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <title>弹力球枪 3D (WebGL)</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000000;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        touch-action: none;
      }
      #hud {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 30;
        color: #e8efff;
        font: 500 14px/1.35 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
        pointer-events: none;
        white-space: pre-line;
      }
      #targetTalkLayer {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 35;
      }
      .target-talk {
        position: absolute;
        transform: translate(-50%, -100%);
        white-space: nowrap;
        font: 500 12px/1.1 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
        color: rgba(240, 246, 255, 0.78);
        text-shadow: 0 1px 4px rgba(0, 0, 0, 0.45);
      }
      #announce {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        padding-bottom: 28vh;
        pointer-events: none;
        z-index: 40;
      }
      #announce.show {
        display: flex;
      }
      #announceCard {
        background: rgba(12, 18, 30, 0.58);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 18px;
        padding: 18px 18px 14px;
        max-width: min(86vw, 460px);
        color: #f2f6ff;
        text-align: center;
        box-shadow: 0 14px 36px rgba(0, 0, 0, 0.4);
      }
      #announceCard img {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid rgba(255, 255, 255, 0.8);
        margin-bottom: 12px;
      }
      #announceCard p {
        margin: 0;
        font: 600 20px/1.35 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
      }
      #danmuLayer {
        position: fixed;
        inset: 0;
        overflow: hidden;
        pointer-events: none;
        z-index: 61;
      }
      .danmu-msg {
        position: absolute;
        left: 0;
        top: 0;
        white-space: nowrap;
        will-change: transform;
        font: 700 25px/1 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
        text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      }
      #restartBtn {
        margin-top: 14px;
        padding: 8px 22px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.4);
        background: rgba(255, 255, 255, 0.16);
        color: #fff;
        font: 600 18px/1 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
        pointer-events: auto;
        cursor: pointer;
      }
      #bgmBtn {
        position: fixed;
        right: 12px;
        top: 12px;
        z-index: 80;
        border: 0;
        border-radius: 999px;
        padding: 8px 14px;
        font: 600 14px/1 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
        color: rgba(245, 248, 255, 0.92);
        background: rgba(20, 28, 44, 0.58);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.28);
        cursor: pointer;
      }
      #ytBgm {
        position: fixed;
        width: 2px;
        height: 2px;
        right: 2px;
        bottom: 2px;
        opacity: 0.01;
        pointer-events: none;
        z-index: 79;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div id="hud"></div>
    <div id="targetTalkLayer"></div>
    <div id="announce">
      <div id="announceCard">
        <img id="announceImg" alt="winner" />
        <p id="announceText"></p>
        <button id="restartBtn" type="button">好的，我一定准时赴约</button>
      </div>
    </div>
    <button id="bgmBtn" type="button">开启音乐</button>
    <div id="danmuLayer"></div>
    <div id="ytBgm" aria-hidden="true"></div>
    <script>
      const canvas = document.getElementById("game");
      const hud = document.getElementById("hud");
      const targetTalkLayer = document.getElementById("targetTalkLayer");
      const announce = document.getElementById("announce");
      const announceImg = document.getElementById("announceImg");
      const announceText = document.getElementById("announceText");
      const bgmBtn = document.getElementById("bgmBtn");
      const danmuLayer = document.getElementById("danmuLayer");
      const ytBgmHost = document.getElementById("ytBgm");
      const restartBtn = document.getElementById("restartBtn");
      const gl = canvas.getContext("webgl", { antialias: true, alpha: false });
      if (!gl) throw new Error("WebGL not supported");
      const isLikelyMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || "") || (window.innerWidth <= 900 && "ontouchstart" in window);
      const PERF = isLikelyMobile
        ? {
            dprCap: 1.1,
            clothCols: 19,
            clothRows: 20,
            clothSubsteps: 3,
            clothIterations: 4,
            ballCcdSubsteps: 6,
            aimSteps: 28,
            ballSphereLat: 8,
            ballSphereLon: 12,
            fragmentSphereLat: 5,
            fragmentSphereLon: 8,
            targetDiscSeg: 24,
            fragmentCount: 8,
            maxActiveBalls: 14,
          }
        : {
            dprCap: 2,
            clothCols: 23,
            clothRows: 24,
            clothSubsteps: 4,
            clothIterations: 6,
            ballCcdSubsteps: 10,
            aimSteps: 46,
            ballSphereLat: 10,
            ballSphereLon: 16,
            fragmentSphereLat: 7,
            fragmentSphereLon: 10,
            targetDiscSeg: 36,
            fragmentCount: 14,
            maxActiveBalls: 999,
          };

      const meshVS = `
        attribute vec3 a_pos;
        attribute vec3 a_nrm;
        attribute vec4 a_col;
        uniform mat4 u_viewProj;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        void main() {
          v_pos = a_pos;
          v_nrm = a_nrm;
          v_col = a_col;
          gl_Position = u_viewProj * vec4(a_pos, 1.0);
        }
      `;
      const meshFS = `
        precision mediump float;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        uniform vec3 u_camPos;
        uniform vec3 u_lightDir;
        uniform vec3 u_lightColor;
        uniform float u_lightIntensity;
        uniform vec3 u_ambColor;
        uniform float u_ambIntensity;
        uniform float u_shininess;
        uniform float u_specStrength;
        void main() {
          vec3 n = normalize(v_nrm);
          vec3 l = normalize(-u_lightDir);
          vec3 v = normalize(u_camPos - v_pos);
          vec3 h = normalize(l + v);
          float ndotl = max(dot(n, l), 0.0);
          float ndoth = max(dot(n, h), 0.0);
          float spec = pow(ndoth, u_shininess) * u_specStrength;

          vec3 amb = v_col.rgb * u_ambColor * u_ambIntensity;
          vec3 diff = v_col.rgb * u_lightColor * (ndotl * u_lightIntensity);
          vec3 col = amb + diff + u_lightColor * spec;
          gl_FragColor = vec4(min(col, vec3(1.0)), v_col.a);
        }
      `;
      const texVS = `
        attribute vec3 a_pos;
        attribute vec3 a_nrm;
        attribute vec4 a_col;
        attribute vec2 a_uv;
        uniform mat4 u_viewProj;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        varying vec2 v_uv;
        void main() {
          v_pos = a_pos;
          v_nrm = a_nrm;
          v_col = a_col;
          v_uv = a_uv;
          gl_Position = u_viewProj * vec4(a_pos, 1.0);
        }
      `;
      const texFS = `
        precision mediump float;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        varying vec2 v_uv;
        uniform sampler2D u_tex;
        uniform float u_redTint;
        uniform vec3 u_camPos;
        uniform vec3 u_lightDir;
        uniform vec3 u_lightColor;
        uniform float u_lightIntensity;
        uniform vec3 u_ambColor;
        uniform float u_ambIntensity;
        void main() {
          vec4 tex = texture2D(u_tex, v_uv);
          if (tex.a < 0.01) discard;

          vec3 base = mix(tex.rgb, vec3(1.0, 0.16, 0.16), clamp(u_redTint, 0.0, 0.45));
          base *= v_col.rgb;

          vec3 n = normalize(v_nrm);
          vec3 l = normalize(-u_lightDir);
          vec3 v = normalize(u_camPos - v_pos);
          vec3 h = normalize(l + v);
          float ndotl = max(dot(n, l), 0.0);
          float ndoth = max(dot(n, h), 0.0);
          float spec = pow(ndoth, 28.0) * 0.25;

          vec3 amb = base * u_ambColor * u_ambIntensity;
          vec3 diff = base * u_lightColor * (ndotl * u_lightIntensity);
          vec3 col = amb + diff + u_lightColor * spec;
          gl_FragColor = vec4(min(col, vec3(1.0)), v_col.a);
        }
      `;
      const lineVS = `
        attribute vec2 a_pos;
        attribute vec4 a_col;
        varying vec4 v_col;
        void main() {
          gl_Position = vec4(a_pos, 0.0, 1.0);
          v_col = a_col;
        }
      `;
      const lineFS = `
        precision mediump float;
        varying vec4 v_col;
        void main() {
          gl_FragColor = v_col;
        }
      `;

      function compile(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
        return s;
      }
      function makeProgram(vsSrc, fsSrc) {
        const p = gl.createProgram();
        gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
        gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
        return p;
      }

      const meshProg = makeProgram(meshVS, meshFS);
      const texProg = makeProgram(texVS, texFS);
      const lineProg = makeProgram(lineVS, lineFS);

      const mesh = {
        prog: meshProg,
        vbo: gl.createBuffer(),
        aPos: gl.getAttribLocation(meshProg, "a_pos"),
        aNrm: gl.getAttribLocation(meshProg, "a_nrm"),
        aCol: gl.getAttribLocation(meshProg, "a_col"),
        uViewProj: gl.getUniformLocation(meshProg, "u_viewProj"),
        uCamPos: gl.getUniformLocation(meshProg, "u_camPos"),
        uLightDir: gl.getUniformLocation(meshProg, "u_lightDir"),
        uLightColor: gl.getUniformLocation(meshProg, "u_lightColor"),
        uLightIntensity: gl.getUniformLocation(meshProg, "u_lightIntensity"),
        uAmbColor: gl.getUniformLocation(meshProg, "u_ambColor"),
        uAmbIntensity: gl.getUniformLocation(meshProg, "u_ambIntensity"),
        uShininess: gl.getUniformLocation(meshProg, "u_shininess"),
        uSpecStrength: gl.getUniformLocation(meshProg, "u_specStrength"),
      };
      const tex = {
        prog: texProg,
        vbo: gl.createBuffer(),
        aPos: gl.getAttribLocation(texProg, "a_pos"),
        aNrm: gl.getAttribLocation(texProg, "a_nrm"),
        aCol: gl.getAttribLocation(texProg, "a_col"),
        aUv: gl.getAttribLocation(texProg, "a_uv"),
        uViewProj: gl.getUniformLocation(texProg, "u_viewProj"),
        uCamPos: gl.getUniformLocation(texProg, "u_camPos"),
        uLightDir: gl.getUniformLocation(texProg, "u_lightDir"),
        uLightColor: gl.getUniformLocation(texProg, "u_lightColor"),
        uLightIntensity: gl.getUniformLocation(texProg, "u_lightIntensity"),
        uAmbColor: gl.getUniformLocation(texProg, "u_ambColor"),
        uAmbIntensity: gl.getUniformLocation(texProg, "u_ambIntensity"),
        uTex: gl.getUniformLocation(texProg, "u_tex"),
        uRedTint: gl.getUniformLocation(texProg, "u_redTint"),
      };
      const line = {
        prog: lineProg,
        vbo: gl.createBuffer(),
        aPos: gl.getAttribLocation(lineProg, "a_pos"),
        aCol: gl.getAttribLocation(lineProg, "a_col"),
      };

      const world = {
        gravity: -22,
        bounce: 0.64,
        wallBounce: 0.78,
        drag: 0.998,
        groundFriction: 0.93,
        targetSpring: 30,
        targetDamping: 8,
        targetGravity: -5,
      };
      const clothSetup = {
        xMin: -9,
        xMax: 9,
        z: 37.0,
        width: 18,
        height: 40,
        topY: 19,
        cols: PERF.clothCols,
        rows: PERF.clothRows,
        substeps: PERF.clothSubsteps,
        iterations: PERF.clothIterations,
        damping: 0.006,
        gravityScale: 2.2,
        stretchCompliance: 0.00006,
        shearCompliance: 0.00009,
        bendCompliance: 0.00022,
        tetherCompliance: 0.00012,
        groundY: 0.03,
        initialReleaseDepth: 14,
        collisionRestitution: 0.0,
        collisionTangentDamping: 0.97,
        collisionSpeedDamping: 0.98,
        collisionDetachSpeed: 0.0,
        collisionMaxOutSpeed: 0.0,
        timeStepScale: 1.8,
        ballCcdSubsteps: PERF.ballCcdSubsteps,
        topEdgeSag: 0.9,
      };

      const cam = {
        pos: { x: 0, y: 3.8, z: -16 },
        target: { x: 0, y: 2.6, z: 14 },
        up: { x: 0, y: 1, z: 0 },
        fovY: Math.PI / 4.1,
        near: 0.1,
        far: 120,
      };
      const directionalLight = {
        dir: normalize3(0.9, -1.1, 1.0),
        color: [1.0, 0.96, 0.9],
        intensity: 1.16,
      };
      const ambientLight = {
        color: [0.5, 0.58, 0.7],
        intensity: 0.2,
      };

      const portraitFiles = [
        "Alan.jpg",
        "Ben.jpg",
        "Humphery.jpg",
        "Jessie.jpg",
        "Jill.jpg",
        "LiuYang.jpg",
        "Lynn.jpg",
        "Milton.jpg",
        "NicoleChen.jpg",
        "Sophie.jpg",
        "WuTong.jpg",
        "ZhangLin.jpg",
        "amit.jpg",
      ];
      const portraits = portraitFiles.map((file) => {
        const img = new Image();
        img.src = `Assets/${file}`;
        const texObj = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texObj);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        const p = {
          file,
          name: file.replace(".jpg", ""),
          src: `Assets/${file}`,
          tex: texObj,
          loaded: false,
        };
        img.onload = () => {
          gl.bindTexture(gl.TEXTURE_2D, texObj);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
          p.loaded = true;
        };
        return p;
      });

      const DEFAULT_INVITE_API = location.hostname.endsWith("github.io")
        ? "https://shooting-git-main-fishfusions-projects.vercel.app/api/invite"
        : "/api/invite";
      const YT_BGM_VIDEO_ID = "urkZLuELFeQ";
      const YT_BGM_URL = `https://www.youtube-nocookie.com/embed/${YT_BGM_VIDEO_ID}?autoplay=1&playsinline=1&loop=1&playlist=${YT_BGM_VIDEO_ID}&controls=0&disablekb=1&rel=0&modestbranding=1`;
      const ORIGINAL_INVITE = "恭喜你，下周六叫上Leo一家来我家吃烧烤吧。";
      const PHILOSOPHICAL_SEEDS = [
        "人生像火候，要慢慢入味",
        "关系的温度，来自一起吃饭",
        "答案常在烟火气里",
        "忙碌之外也要留白给朋友",
        "快乐在分享里变大",
      ];
      const FALLBACK_INVITE_LINES = [
        "下周六你叫上Leo一家来我家吃烧烤，很多话在烟火里更容易说清楚。",
        "下周末你叫上Leo一家来我家吃烧烤吧，关系总要靠见面慢慢升温。",
        "明晚你先和Leo一家约好，下周末一起来我家吃烧烤，热闹会把疲惫吹散。",
        "这个周末你叫上Leo一家来我家吃烧烤，答案有时就藏在一桌人间烟火里。",
      ];
      const INVITE_PHILOSOPHICAL_TAILS = [
        "人与人的情分，往往就在一顿饭的烟火里慢慢长出来。",
        "很多难说的话，坐在同一张桌前就有了温度。",
        "人生的分量，不只在远方，也在一起举杯的当下。",
        "真正能留下来的关系，常常是被一餐一饭认真喂养的。",
        "热闹会散，但一起吃过的那份真心会一直在。",
        "再忙的日子，也该给重要的人留一段同桌的时间。",
      ];
      const FIRE_RATE_LIMIT = {
        windowSec: 0.5,
        maxShots: 1,
        popupCooldownSec: 1.6,
      };
      const RATE_WARNING_FALLBACK = "省这点弹药，咱穷。";
      const RATE_WARNING_POOL_SIZE = 3;
      const RATE_WARNING_HEADS = [
        "别急，",
        "慢点，",
        "收手，",
        "克制点，",
        "你这手速，",
        "先稳住，",
        "节奏乱了，",
        "别上头，",
        "冷静一下，",
        "先喘口气，",
        "别猛扣，",
        "留点余地，",
        "别贪快，",
        "稳着打，",
        "火力太急，",
        "你这样打，",
        "再这么冲，",
        "压一压，",
        "先慢半拍，",
        "控制一下，",
      ];
      const RATE_WARNING_TAILS = [
        "弹药要见底了。",
        "很快就见空仓。",
        "会把家底打穿。",
        "库存扛不住了。",
        "后面会断火。",
        "子弹要吃紧了。",
        "再快就要穷了。",
        "一会儿就打光。",
        "别把预算点没了。",
        "这样会弹尽粮绝。",
        "后劲会不够。",
        "弹链已经冒烟了。",
        "很快只剩回声。",
        "再扣就只剩空气。",
        "省这点弹药，咱穷。",
      ];
      const RATE_WARNING_LINES = (() => {
        const out = [];
        for (const h of RATE_WARNING_HEADS) {
          for (const t of RATE_WARNING_TAILS) out.push(`${h}${t}`);
        }
        return out; // 20 * 15 = 300 hardcoded lines
      })();
      const MISS_TAUNT_TRIGGER = 3;
      const MISS_TAUNT_FALLBACK = "你这准心着实不行啊。";
      const MISS_TAUNT_HEADS = [
        "你这准心，",
        "这枪法，",
        "这手感，",
        "你这瞄法，",
        "看得出来，",
        "兄弟你这波，",
        "这连空，",
        "你今天这状态，",
        "这节奏，",
        "你这开火姿势，",
        "这准头，",
        "你这眼神，",
        "你这手一抖，",
        "你这压枪，",
        "这发散，",
        "这不叫射击，",
        "你这连点，",
        "你这预判，",
        "这都能空，",
        "你这火力分配，",
      ];
      const MISS_TAUNT_TAILS = [
        "着实不行啊。",
        "像在给空气理发。",
        "靶子都替你着急。",
        "风都比你打得准。",
        "建议先找回准心。",
        "像在和命中率绝交。",
        "再空就要笑场了。",
        "全场都在等你中一发。",
        "准心今天在休假。",
        "子弹都不知道去哪。",
        "打得挺热闹，命中挺安静。",
        "建议先深呼吸再扣扳机。",
        "再这么打要被靶子教育了。",
        "像在给背景做特效。",
        "这波操作很有想象力。",
      ];
      const MISS_TAUNT_LINES = (() => {
        const out = [];
        for (const h of MISS_TAUNT_HEADS) {
          for (const t of MISS_TAUNT_TAILS) out.push(`${h}${t}`);
        }
        return out; // 20 * 15 = 300 hardcoded lines
      })();
      const TARGET_TALK_HEADS = [
        "有本事就来，",
        "来啊来啊，",
        "别客气，",
        "冲我来，",
        "看准了再打，",
        "你敢不敢，",
        "再靠近点，",
        "别怂，",
        "快点出手，",
        "准星别飘，",
        "眼神跟上，",
        "手稳一点，",
        "节奏提起来，",
        "火力压过来，",
        "别只会吓唬人，",
        "你这就上，",
        "就等你这一发，",
        "别磨蹭，",
        "来点真本事，",
        "敢打就打，",
      ];
      const TARGET_TALK_TAILS = [
        "有本事打我呀。",
        "打中我算你厉害。",
        "别只会擦边。",
        "让子弹说话。",
        "别让准星走神。",
        "冲着我来一发。",
        "给我看看火候。",
        "别打空气了。",
        "要不你再瞄瞄？",
        "来一枪痛快的。",
        "别客气，打我呀。",
        "别让我等太久。",
        "就这点胆量吗？",
        "有种就命中我。",
        "来，正面刚。",
      ];
      const TARGET_TALK_LINES = (() => {
        const out = [];
        for (const h of TARGET_TALK_HEADS) {
          for (const t of TARGET_TALK_TAILS) out.push(`${h}${t}`);
        }
        return out; // 20 * 15 = 300 hardcoded lines
      })();
      const TARGET_HIT_TAUNT_FALLBACK = "狗屎运打中的吧。";
      const TARGET_HIT_TAUNT_HEADS = [
        "狗屎运，",
        "这发也算，",
        "你这一下，",
        "这就中啦，",
        "巧合吧，",
        "蒙中的吧，",
        "歪打正着，",
        "运气不错，",
        "这球路，",
        "这一枪，",
        "这都能中，",
        "你这手气，",
        "刚好蹭到，",
        "险些没中，",
        "这准头，",
        "碰巧了，",
        "这命中，",
        "看着像是，",
        "有点玄学，",
        "你别得意，",
      ];
      const TARGET_HIT_TAUNT_TAILS = [
        "打中的吧。",
        "算你走运。",
        "纯靠手气。",
        "刚好碰上。",
        "别太当真。",
        "下次未必。",
        "这一发不作数。",
        "算你捡到。",
        "我没准备好。",
        "有点离谱啊。",
        "真是巧了。",
        "你先别笑。",
        "下把见真章。",
        "刚好擦进来。",
        "这次放你过。",
      ];
      const TARGET_HIT_TAUNT_LINES = (() => {
        const out = [];
        for (const h of TARGET_HIT_TAUNT_HEADS) {
          for (const t of TARGET_HIT_TAUNT_TAILS) out.push(`${h}${t}`);
        }
        return out; // 20 * 15 = 300 hardcoded lines
      })();
      const TARGET_HIT_TAUNT_SEC = 1.5;
      const TARGET_TALK_ON_SEC = 2.0;
      const TARGET_TALK_OFF_SEC = 2.0;
      const DANMU_CFG = {
        topOffset: 72,
        laneHeight: 34,
        maxLanes: 7,
        minLanes: 4,
        speedPxPerSec: 260,
        laneGapPx: 120,
      };
      const DANMU_COLOR_POOL = [
        "rgba(138, 237, 255, 0.56)",
        "rgba(167, 255, 212, 0.56)",
        "rgba(255, 244, 142, 0.56)",
        "rgba(173, 208, 255, 0.56)",
        "rgba(206, 255, 150, 0.56)",
        "rgba(255, 214, 130, 0.56)",
        "rgba(201, 255, 245, 0.56)",
      ];
      const state = {
        screenW: 0,
        screenH: 0,
        viewProj: identity4(),
        gun: { x: 0, y: 1.2, z: -6 },
        aim: { yaw: 0, pitch: 0.28, power: 0.35 },
        drag: { active: false, x: 0, y: 0 },
        balls: [],
        fragments: [],
        targets: [],
        score: 0,
        gameOver: false,
        gameOverText: "",
        announceSrc: "",
        announceName: "",
        lastInviteLine: "",
        preparedInviteLine: "",
        invitePrefetching: false,
        preparedRateWarningLine: "",
        rateWarningPool: [],
        lastRateWarningLine: "",
        preparedMissTauntLine: "",
        missTauntPool: [],
        lastMissTauntLine: "",
        targetHitTauntPool: [],
        consecutiveMissShots: 0,
        targetTalkPool: [],
        targetTalkActiveIndices: [],
        targetTalkVisible: false,
        targetTalkNextSwitch: 0,
        targetTalkNodes: [],
        recentShotTs: [],
        nextRatePopupTime: 0,
        announceMode: "gameover",
        danmuLanes: [],
        lastDanmuColorIndex: -1,
        bgmRetryCount: 0,
        bgmIframeMounted: false,
        cloth: null,
        lastPortraitSet: "",
        lastT: performance.now(),
      };

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }
      function shuffled(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const t = a[i];
          a[i] = a[j];
          a[j] = t;
        }
        return a;
      }
      function hasTimePhrase(text) {
        return /(下周[一二三四五六日天末]?|周[一二三四五六日天末]|周末|今晚|明晚|明天|后天|本周|这个周末|下个周末)/.test(text);
      }
      function resetDanmuLanes() {
        const usableH = Math.max(160, state.screenH * 0.42);
        const laneCount = clamp(Math.floor(usableH / DANMU_CFG.laneHeight), DANMU_CFG.minLanes, DANMU_CFG.maxLanes);
        state.danmuLanes = new Array(laneCount).fill(0).map(() => ({ nextStartAt: 0 }));
      }
      function emitDanmu(text, kind) {
        if (!text || !danmuLayer) return;
        if (!state.danmuLanes.length) resetDanmuLanes();
        const now = performance.now();
        let laneIndex = 0;
        let laneReady = state.danmuLanes[0].nextStartAt;
        for (let i = 1; i < state.danmuLanes.length; i++) {
          if (state.danmuLanes[i].nextStartAt < laneReady) {
            laneReady = state.danmuLanes[i].nextStartAt;
            laneIndex = i;
          }
        }
        const delay = Math.max(0, laneReady - now);
        const laneTop = DANMU_CFG.topOffset + laneIndex * DANMU_CFG.laneHeight;

        const node = document.createElement("div");
        node.className = `danmu-msg ${kind === "taunt" ? "taunt" : "warning"}`;
        node.textContent = text;
        let colorIndex = Math.floor(Math.random() * DANMU_COLOR_POOL.length);
        if (DANMU_COLOR_POOL.length > 1 && colorIndex === state.lastDanmuColorIndex) {
          colorIndex = (colorIndex + 1 + Math.floor(Math.random() * (DANMU_COLOR_POOL.length - 1))) % DANMU_COLOR_POOL.length;
        }
        state.lastDanmuColorIndex = colorIndex;
        node.style.color = DANMU_COLOR_POOL[colorIndex];
        node.style.top = `${laneTop}px`;
        node.style.transform = `translateX(${state.screenW + 32}px)`;
        danmuLayer.appendChild(node);

        const width = Math.max(60, Math.ceil(node.getBoundingClientRect().width));
        const moveDistance = state.screenW + width + 120;
        const moveDurationMs = (moveDistance / DANMU_CFG.speedPxPerSec) * 1000;
        const safeGapMs = ((width + DANMU_CFG.laneGapPx) / DANMU_CFG.speedPxPerSec) * 1000;
        state.danmuLanes[laneIndex].nextStartAt = now + delay + safeGapMs;

        const go = () => {
          node.style.transition = `transform ${moveDurationMs}ms linear`;
          node.style.transform = `translateX(${-width - 80}px)`;
        };
        if (delay > 0) {
          setTimeout(() => requestAnimationFrame(go), delay);
        } else {
          requestAnimationFrame(go);
        }
        setTimeout(() => {
          if (node.parentNode) node.parentNode.removeChild(node);
        }, delay + moveDurationMs + 120);
      }
      function tryStartBgm(manual) {
        if (!ytBgmHost) return;
        const isManual = !!manual;
        if (isManual) {
          state.bgmRetryCount += 1;
          if (bgmBtn) bgmBtn.textContent = "音乐开启中...";
        }
        try {
          const forceReload = isManual;
          if (!state.bgmIframeMounted || forceReload) {
            const iframe = document.createElement("iframe");
            iframe.width = "2";
            iframe.height = "2";
            iframe.src = `${YT_BGM_URL}&t=${Date.now()}`;
            iframe.title = "bgm";
            iframe.allow = "autoplay; encrypted-media; picture-in-picture";
            iframe.referrerPolicy = "strict-origin-when-cross-origin";
            iframe.frameBorder = "0";
            ytBgmHost.textContent = "";
            ytBgmHost.appendChild(iframe);
            state.bgmIframeMounted = true;
          } else {
            const iframe = ytBgmHost.querySelector("iframe");
            if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(
                JSON.stringify({ event: "command", func: "playVideo", args: [] }),
                "*"
              );
            }
          }
          if (isManual && bgmBtn) bgmBtn.textContent = "没声音就再点一次";
        } catch (_err) {}
      }
      function extendInviteLine(baseLine) {
        const base = String(baseLine || "").trim();
        if (!base) return base;
        const withStop = /[。！？!?]$/.test(base) ? base : `${base}。`;
        const tail = INVITE_PHILOSOPHICAL_TAILS[Math.floor(Math.random() * INVITE_PHILOSOPHICAL_TAILS.length)] || INVITE_PHILOSOPHICAL_TAILS[0];
        return `${withStop}${tail}`;
      }

      async function requestProxyLine(apiUrl, payload) {
        const res = await fetch(apiUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          const t = await res.text();
          return { ok: false, detail: `HTTP ${res.status} ${t.slice(0, 140)}` };
        }
        const data = await res.json();
        const text = String(data.text || "").trim();
        if (!text) return { ok: false, detail: "empty response text" };
        return { ok: true, text };
      }

      async function generatePhilosophicalInviteLine() {
        const customApiUrl = String(localStorage.getItem("OPENAI_PROXY_URL") || "").trim();
        const useCustomOnGithub = customApiUrl && !customApiUrl.startsWith("/");
        const apiCandidates =
          customApiUrl && customApiUrl !== DEFAULT_INVITE_API && (!location.hostname.endsWith("github.io") || useCustomOnGithub)
            ? [customApiUrl, DEFAULT_INVITE_API]
            : [DEFAULT_INVITE_API];
        let lastErr = "";
        for (let attempt = 0; attempt < 5; attempt++) {
          const seed = PHILOSOPHICAL_SEEDS[Math.floor(Math.random() * PHILOSOPHICAL_SEEDS.length)];
          const nonce = `${Date.now().toString(36)}-${attempt}`;
          const prompt = `写一句中文邀请语，必须保留核心意思：你下周末叫上Leo一家来我家吃烧烤。句子里必须出现一个明确时间点（例如：下周六/周日/周末/明晚）。语气自然，有一点哲理，不要鸡汤，不要解释，只输出一句话。可参考意象：${seed}。避免与这句重复：${state.lastInviteLine || "无"}。随机标记:${nonce}`;
          for (const apiUrl of apiCandidates) {
            try {
              const result = await requestProxyLine(apiUrl, {
                mode: "invite",
                input: prompt,
                lastInviteLine: state.lastInviteLine || "",
              });
              if (!result.ok) {
                lastErr = `${apiUrl} -> ${result.detail}`;
                continue;
              }
              const text = result.text;
              let clean = text.replace(/^["'“”]+|["'“”]+$/g, "");
              if (clean === ORIGINAL_INVITE) continue;
              if (/^\s*Leo[，,:：\s]/i.test(clean)) continue;
              if (!/叫上\s*Leo(?:一家)?/i.test(clean)) clean = `下周末你叫上Leo一家，${clean}`;
              if (!/你/.test(clean)) clean = `你${clean}`;
              if (!hasTimePhrase(clean)) clean = `下周六${clean}`;
              if (!/Leo/i.test(clean)) clean = `${clean} 叫上Leo一家。`;
              if (!/烧烤/.test(clean)) clean = `${clean} 来我家吃烧烤吧。`;
              if (clean === state.lastInviteLine) continue;
              return clean;
            } catch (_err) {
              lastErr = `${apiUrl} -> ${String(_err && _err.message ? _err.message : _err)}`;
              continue;
            }
          }
        }
        if (lastErr) console.warn("invite proxy failed, using fallback line:", lastErr);
        const fallback = FALLBACK_INVITE_LINES[Math.floor(Math.random() * FALLBACK_INVITE_LINES.length)];
        return `__FALLBACK_INVITE__${fallback}`;
      }

      function generateRateWarningLine() {
        if (!state.rateWarningPool.length) {
          state.rateWarningPool = shuffled(RATE_WARNING_LINES);
        }
        let line = state.rateWarningPool.pop() || RATE_WARNING_FALLBACK;
        if (line === state.lastRateWarningLine && state.rateWarningPool.length) {
          line = state.rateWarningPool.pop() || line;
        }
        return line;
      }

      async function showAnnouncement(src) {
        if (danmuLayer) danmuLayer.textContent = "";
        for (const lane of state.danmuLanes) lane.nextStartAt = 0;
        announceImg.src = src;
        announce.classList.add("show");
        state.announceMode = "gameover";
        restartBtn.style.display = "";
        let line = state.preparedInviteLine || "";
        state.preparedInviteLine = "";
        if (!line) {
          line = await generatePhilosophicalInviteLine();
        }
        if (line.startsWith("__FALLBACK_INVITE__")) {
          const text = line.replace("__FALLBACK_INVITE__", "");
          announceText.textContent = extendInviteLine(text);
          primeInviteLine();
          return;
        }
        state.lastInviteLine = line;
        announceText.textContent = extendInviteLine(line);
        primeInviteLine();
      }

      function showRateWarningPopup(line) {
        if (state.gameOver) return;
        emitDanmu(line || RATE_WARNING_FALLBACK, "warning");
      }
      function showMissTauntPopup(line) {
        if (state.gameOver) return;
        emitDanmu(line || MISS_TAUNT_FALLBACK, "taunt");
      }

      function primeInviteLine() {
        if (state.invitePrefetching || state.preparedInviteLine) return;
        state.invitePrefetching = true;
        generatePhilosophicalInviteLine()
          .then((line) => {
            if (line) state.preparedInviteLine = line;
          })
          .finally(() => {
            state.invitePrefetching = false;
          });
      }
      function primeRateWarningLine() {
        if (!state.preparedRateWarningLine) {
          state.preparedRateWarningLine = generateRateWarningLine();
        }
      }
      function generateMissTauntLine() {
        if (!state.missTauntPool.length) {
          state.missTauntPool = shuffled(MISS_TAUNT_LINES);
        }
        let line = state.missTauntPool.pop() || MISS_TAUNT_FALLBACK;
        if (line === state.lastMissTauntLine && state.missTauntPool.length) {
          line = state.missTauntPool.pop() || line;
        }
        return line;
      }
      function primeMissTauntLine() {
        if (!state.preparedMissTauntLine) {
          state.preparedMissTauntLine = generateMissTauntLine();
        }
      }
      function nextTargetHitTauntLine() {
        if (!state.targetHitTauntPool.length) {
          state.targetHitTauntPool = shuffled(TARGET_HIT_TAUNT_LINES);
        }
        return state.targetHitTauntPool.pop() || TARGET_HIT_TAUNT_FALLBACK;
      }
      function registerMissedShot() {
        if (state.gameOver) return;
        state.consecutiveMissShots += 1;
        if (state.consecutiveMissShots < MISS_TAUNT_TRIGGER) return;
        const line = state.preparedMissTauntLine || MISS_TAUNT_FALLBACK;
        state.preparedMissTauntLine = "";
        state.lastMissTauntLine = line;
        state.consecutiveMissShots = 0;
        showMissTauntPopup(line);
        primeMissTauntLine();
      }
      function hitFireRateLimit() {
        const now = performance.now() * 0.001;
        const lo = now - FIRE_RATE_LIMIT.windowSec;
        state.recentShotTs = state.recentShotTs.filter((t) => t >= lo);
        if (state.recentShotTs.length >= FIRE_RATE_LIMIT.maxShots) {
          if (now >= state.nextRatePopupTime) {
            state.nextRatePopupTime = now + FIRE_RATE_LIMIT.popupCooldownSec;
            const line = state.preparedRateWarningLine || RATE_WARNING_FALLBACK;
            state.preparedRateWarningLine = "";
            state.lastRateWarningLine = line;
            showRateWarningPopup(line);
            primeRateWarningLine();
          }
          return true;
        }
        state.recentShotTs.push(now);
        return false;
      }

      function resize() {
        const dprCap = PERF.dprCap;
        const dpr = Math.min(dprCap, window.devicePixelRatio || 1);
        state.screenW = window.innerWidth;
        state.screenH = window.innerHeight;
        canvas.width = Math.floor(state.screenW * dpr);
        canvas.height = Math.floor(state.screenH * dpr);
        gl.viewport(0, 0, canvas.width, canvas.height);
        resetDanmuLanes();
      }

      function createTargets() {
        const targetCount = 5;
        const xs = [-5.4, -2.9, -0.2, 2.4, 5.0];
        const ys = [2.5, 3.4, 3.0, 4.2, 3.3];
        const rs = [0.84, 1.02, 0.78, 1.24, 0.94].map((v) => v * 1.2);
        const speed = [0.85, 1.25, 1.0, 1.55, 0.95];
        const zs = [14, 19, 24, 29, 34];
        const nearZ = Math.min(...zs);
        const farZ = Math.max(...zs);

        state.gameOver = false;
        state.gameOverText = "";
        state.announceSrc = "";
        state.announceName = "";
        announce.classList.remove("show");
        if (danmuLayer) danmuLayer.textContent = "";
        for (const lane of state.danmuLanes) lane.nextStartAt = 0;
        restartBtn.style.display = "";
        state.announceMode = "gameover";
        state.balls = [];
        state.fragments = [];
        state.score = 0;
        state.targets = [];
        if (targetTalkLayer) targetTalkLayer.textContent = "";
        state.targetTalkNodes = [];
        state.recentShotTs = [];
        state.preparedRateWarningLine = "";
        state.rateWarningPool = shuffled(RATE_WARNING_LINES);
        state.preparedMissTauntLine = "";
        state.missTauntPool = shuffled(MISS_TAUNT_LINES);
        state.targetHitTauntPool = shuffled(TARGET_HIT_TAUNT_LINES);
        state.targetTalkPool = shuffled(TARGET_TALK_LINES);
        state.targetTalkActiveIndices = [];
        state.targetTalkVisible = false;
        state.targetTalkNextSwitch = 0;
        state.lastMissTauntLine = "";
        state.consecutiveMissShots = 0;
        state.nextRatePopupTime = 0;
        initCloth();
        state.preparedInviteLine = "";
        state.invitePrefetching = false;

        let selectedPortraits = shuffled(portraits).slice(0, targetCount);
        let sig = selectedPortraits.map((p) => p.file).join("|");
        // 避免“点击确定后看起来没换图”：新一局与上一局至少顺序不同。
        if (state.lastPortraitSet && sig === state.lastPortraitSet) {
          for (let i = 0; i < 6; i++) {
            selectedPortraits = shuffled(portraits).slice(0, targetCount);
            sig = selectedPortraits.map((p) => p.file).join("|");
            if (sig !== state.lastPortraitSet) break;
          }
        }
        state.lastPortraitSet = sig;
        for (let i = 0; i < targetCount; i++) {
          if (!state.targetTalkPool.length) state.targetTalkPool = shuffled(TARGET_TALK_LINES);
          const z = zs[i];
          const near01 = (farZ - z) / (farZ - nearZ);
          const maxHp = Math.round((70 + near01 * 90) * 1.5 * 0.75 * 1.2);
          state.targets.push({
            baseX: xs[i],
            baseY: ys[i],
            z,
            x: xs[i],
            y: ys[i],
            baseR: rs[i],
            r: rs[i],
            vx: 0,
            vy: 0,
            mass: 1.1 + rs[i] * 2.0,
            sx: (2.2 + i * 0.45) * (i % 2 ? -1 : 1),
            sy: (1.9 + i * 0.32) * 2,
            wx: speed[i] * 2.3 * 0.7,
            wy: speed[i] * 1.8 * 0.7,
            phase: i * 0.8,
            anchorX: xs[i],
            anchorY: ys[i] + rs[i],
            hitTimer: 0,
            maxHp,
            hp: maxHp,
            dead: false,
            vz: 0,
            rotX: 0,
            rotY: 0,
            rotZ: 0,
            avX: 0,
            avY: 0,
            avZ: 0,
            portrait: selectedPortraits[i],
            talk: state.targetTalkPool.pop() || "有本事打我呀。",
            hitTaunt: "",
            hitTauntUntil: 0,
          });
        }
        primeInviteLine();
        primeRateWarningLine();
        primeMissTauntLine();
      }

      function initCloth() {
        const cols = clothSetup.cols;
        const rows = clothSetup.rows;
        const width = clothSetup.width;
        const height = clothSetup.height;
        const dx = width / (cols - 1);
        const dy = height / (rows - 1);
        const nodes = new Array(cols * rows);
        const constraints = [];

        const addConstraint = (i0, i1, compliance) => {
          const a = nodes[i0];
          const b = nodes[i1];
          const rx = a.x - b.x;
          const ry = a.y - b.y;
          const rz = a.z - b.z;
          constraints.push({
            i0,
            i1,
            rest: Math.hypot(rx, ry, rz),
            compliance,
            lambda: 0,
          });
        };
        const rivetCols = new Set([0, Math.round((cols - 1) / 3), Math.round(((cols - 1) * 2) / 3), cols - 1]);
        const rivetList = Array.from(rivetCols).sort((a, b) => a - b);
        const topSagAt = (x) => {
          if (rivetCols.has(x)) return 0;
          for (let i = 0; i < rivetList.length - 1; i++) {
            const a = rivetList[i];
            const b = rivetList[i + 1];
            if (x < a || x > b) continue;
            const span = Math.max(1, b - a);
            const u = (x - a) / span;
            return 4 * u * (1 - u) * clothSetup.topEdgeSag;
          }
          return clothSetup.topEdgeSag * 0.5;
        };

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const px = clothSetup.xMin + x * dx;
            const pin = y === 0 && rivetCols.has(x);
            const release01 = y / Math.max(1, rows - 1);
            let py = Math.max(clothSetup.groundY, clothSetup.topY - y * dy);
            if (y === 0 && !pin) py -= topSagAt(x);
            const pz = pin ? clothSetup.z : clothSetup.z + clothSetup.initialReleaseDepth * release01;
            nodes[x + y * cols] = {
              x: px,
              y: py,
              z: pz,
              px,
              py,
              pz,
              invMass: pin ? 0 : 1,
            };
          }
        }

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const i = x + y * cols;
            if (x < cols - 1) addConstraint(i, i + 1, clothSetup.stretchCompliance);
            if (y < rows - 1) addConstraint(i, i + cols, clothSetup.stretchCompliance);
            if (x < cols - 2) addConstraint(i, i + 2, clothSetup.bendCompliance);
            if (y < rows - 2) addConstraint(i, i + cols * 2, clothSetup.bendCompliance);
            if (x < cols - 1 && y < rows - 1) {
              addConstraint(i, i + cols + 1, clothSetup.shearCompliance);
              addConstraint(i + 1, i + cols, clothSetup.shearCompliance);
            }
          }
        }

        state.cloth = { cols, rows, nodes, constraints, rivetCols: Array.from(rivetCols) };
      }

      function solveClothConstraints(stepDt) {
        const cloth = state.cloth;
        if (!cloth) return;
        const alphaScale = 1 / (stepDt * stepDt);
        for (const c of cloth.constraints) {
          const a = cloth.nodes[c.i0];
          const b = cloth.nodes[c.i1];
          const w0 = a.invMass;
          const w1 = b.invMass;
          if (w0 + w1 <= 0) continue;
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const dz = a.z - b.z;
          const len = Math.hypot(dx, dy, dz);
          if (len < 1e-6) continue;
          const nx = dx / len;
          const ny = dy / len;
          const nz = dz / len;
          const C = len - c.rest;
          const alpha = c.compliance * alphaScale;
          const dl = (-C - alpha * c.lambda) / (w0 + w1 + alpha);
          c.lambda += dl;
          a.x += nx * dl * w0;
          a.y += ny * dl * w0;
          a.z += nz * dl * w0;
          b.x -= nx * dl * w1;
          b.y -= ny * dl * w1;
          b.z -= nz * dl * w1;
        }
      }

      function solveClothBallCollision(applyVelocityResponse) {
        const cloth = state.cloth;
        if (!cloth) return;
        const restitution = clothSetup.collisionRestitution;
        const tangentDamping = clothSetup.collisionTangentDamping;
        const speedDamping = clothSetup.collisionSpeedDamping;
        for (const ball of state.balls) {
          if (!ball.alive || ball.stopped) continue;
          const invBallMass = 1 / Math.max(0.0001, ball.mass || 1);
          let hit = false;
          let nsumX = 0;
          let nsumY = 0;
          let nsumZ = 0;
          let maxPen = 0;
          for (const n of cloth.nodes) {
            if (n.invMass <= 0) continue;
            const rr = ball.r + 0.05;
            const dx = n.x - ball.x;
            const dy = n.y - ball.y;
            const dz = n.z - ball.z;
            const d = Math.hypot(dx, dy, dz);
            if (d >= rr || d < 1e-6) continue;
            const nx = dx / d;
            const ny = dy / d;
            const nz = dz / d;
            const push = rr - d;
            maxPen = Math.max(maxPen, push);
            hit = true;
            nsumX += nx * push;
            nsumY += ny * push;
            nsumZ += nz * push;
            // Push cloth and slightly push ball out to avoid persistent penetration.
            const ballShare = 0.18 * invBallMass;
            const clothShare = 1 - ballShare;
            n.x += nx * push * clothShare;
            n.y += ny * push * clothShare;
            n.z += nz * push * clothShare;
            ball.x -= nx * push * ballShare;
            ball.y -= ny * push * ballShare;
            ball.z -= nz * push * ballShare;
          }
          if (!hit) continue;

          const nm = Math.hypot(nsumX, nsumY, nsumZ) || 1;
          const nx = nsumX / nm;
          const ny = nsumY / nm;
          const nz = nsumZ / nm;
          if (!applyVelocityResponse) continue;

          // Remove incoming normal speed (no bounce), keep a tiny rebound only if configured.
          const vn = ball.vx * nx + ball.vy * ny + ball.vz * nz;
          if (vn > 0) {
            const keep = -vn * restitution;
            const dv = vn - keep;
            ball.vx -= nx * dv * invBallMass;
            ball.vy -= ny * dv * invBallMass;
            ball.vz -= nz * dv * invBallMass;
          }

          // Cloth friction + bulk energy loss.
          const vnn = ball.vx * nx + ball.vy * ny + ball.vz * nz;
          const vnx = nx * vnn;
          const vny = ny * vnn;
          const vnz = nz * vnn;
          const vtx = ball.vx - vnx;
          const vty = ball.vy - vny;
          const vtz = ball.vz - vnz;
          ball.vx = vnx + vtx * tangentDamping;
          ball.vy = vny + vty * tangentDamping;
          ball.vz = vnz + vtz * tangentDamping;

          // Optional outgoing cap (kept disabled by default).
          if (clothSetup.collisionMaxOutSpeed > 0) {
            const outVn = ball.vx * nx + ball.vy * ny + ball.vz * nz;
            if (outVn < 0) {
              const keepOut = Math.max(outVn, -clothSetup.collisionMaxOutSpeed);
              const cut = outVn - keepOut;
              ball.vx -= nx * cut;
              ball.vy -= ny * cut;
              ball.vz -= nz * cut;
            }
          }

          const penDamp = Math.max(0.9, 1 - maxPen * 0.4);
          ball.vx *= speedDamping * penDamp;
          ball.vy *= speedDamping * penDamp;
          ball.vz *= speedDamping * penDamp;

          // Prevent sticky contact: ensure a minimum separation speed away from cloth.
          const afterVn = ball.vx * nx + ball.vy * ny + ball.vz * nz;
          const minOut = -clothSetup.collisionDetachSpeed;
          if (afterVn > minOut) {
            const dv = minOut - afterVn;
            ball.vx += nx * dv * invBallMass;
            ball.vy += ny * dv * invBallMass;
            ball.vz += nz * dv * invBallMass;
          }
          const capOut = -clothSetup.collisionMaxOutSpeed;
          const finalVn = ball.vx * nx + ball.vy * ny + ball.vz * nz;
          if (finalVn < capOut) {
            const dvCap = capOut - finalVn;
            ball.vx += nx * dvCap * invBallMass;
            ball.vy += ny * dvCap * invBallMass;
            ball.vz += nz * dvCap * invBallMass;
          }
          ball.hitCd = Math.max(ball.hitCd, 0.03);
        }
      }

      function solveClothGroundCollision() {
        const cloth = state.cloth;
        if (!cloth) return;
        const gy = clothSetup.groundY;
        for (const n of cloth.nodes) {
          if (n.invMass <= 0) continue;
          if (n.y < gy) {
            n.y = gy;
            // Zero normal velocity on contact to avoid numerical "ground bounce".
            if (n.py < gy) n.py = gy;
          }
        }
      }

      function resolveBallClothSweep(ball, prev) {
        const cloth = state.cloth;
        if (!cloth) return;
        const sx = prev.x, sy = prev.y, sz = prev.z;
        const ex = ball.x, ey = ball.y, ez = ball.z;
        const dx = ex - sx, dy = ey - sy, dz = ez - sz;
        const segLen2 = dx * dx + dy * dy + dz * dz;
        if (segLen2 < 1e-8) return;

        const rr = ball.r + 0.16;
        const minX = clothSetup.xMin - rr - 0.4;
        const maxX = clothSetup.xMax + rr + 0.4;
        const minY = clothSetup.groundY - rr - 0.25;
        const maxY = clothSetup.topY + rr + 0.9;
        const minZ = clothSetup.z - rr - 0.5;
        const maxZ = clothSetup.z + clothSetup.initialReleaseDepth + rr + 0.8;
        if ((sx < minX && ex < minX) || (sx > maxX && ex > maxX)) return;
        if ((sy < minY && ey < minY) || (sy > maxY && ey > maxY)) return;
        if ((sz < minZ && ez < minZ) || (sz > maxZ && ez > maxZ)) return;
        let hit = false;
        let bestT = 1;
        let hitNx = 0, hitNy = 0, hitNz = 0;
        const insideTri = (p, a, b, c, n) => {
          const e0 = sub3(b, a), vp0 = sub3(p, a);
          const e1 = sub3(c, b), vp1 = sub3(p, b);
          const e2 = sub3(a, c), vp2 = sub3(p, c);
          const c0 = dot3(cross3(e0, vp0), n);
          const c1 = dot3(cross3(e1, vp1), n);
          const c2 = dot3(cross3(e2, vp2), n);
          const eps = -1e-5;
          return c0 >= eps && c1 >= eps && c2 >= eps;
        };
        const trySweepTri = (a, b, c) => {
          const ab = sub3(b, a);
          const ac = sub3(c, a);
          const rawN = cross3(ab, ac);
          const nLen = Math.hypot(rawN.x, rawN.y, rawN.z);
          if (nLen < 1e-8) return;
          const n = { x: rawN.x / nLen, y: rawN.y / nLen, z: rawN.z / nLen };

          const d0 = (sx - a.x) * n.x + (sy - a.y) * n.y + (sz - a.z) * n.z;
          const d1 = (ex - a.x) * n.x + (ey - a.y) * n.y + (ez - a.z) * n.z;
          const dd = d1 - d0;
          if (Math.abs(dd) < 1e-8) return;

          for (const side of [1, -1]) {
            const target = rr * side;
            const t = (target - d0) / dd;
            if (t < 0 || t > bestT) continue;
            const cx = sx + dx * t;
            const cy = sy + dy * t;
            const cz = sz + dz * t;
            const dist = (cx - a.x) * n.x + (cy - a.y) * n.y + (cz - a.z) * n.z;
            const p = { x: cx - n.x * dist, y: cy - n.y * dist, z: cz - n.z * dist };
            if (!insideTri(p, a, b, c, n)) continue;
            hit = true;
            bestT = t;
            hitNx = n.x * side;
            hitNy = n.y * side;
            hitNz = n.z * side;
          }
        };

        for (let y = 0; y < cloth.rows - 1; y++) {
          for (let x = 0; x < cloth.cols - 1; x++) {
            const i00 = x + y * cloth.cols;
            const i10 = i00 + 1;
            const i01 = i00 + cloth.cols;
            const i11 = i01 + 1;
            const p00 = cloth.nodes[i00];
            const p10 = cloth.nodes[i10];
            const p01 = cloth.nodes[i01];
            const p11 = cloth.nodes[i11];
            trySweepTri(p00, p01, p11);
            trySweepTri(p00, p11, p10);
          }
        }

        // Fallback for edge/corner cases: node sweep.
        if (!hit) {
          for (const n of cloth.nodes) {
            const wx = n.x - sx;
            const wy = n.y - sy;
            const wz = n.z - sz;
            const t = clamp((wx * dx + wy * dy + wz * dz) / segLen2, 0, 1);
            const cx = sx + dx * t;
            const cy = sy + dy * t;
            const cz = sz + dz * t;
            const ox = cx - n.x;
            const oy = cy - n.y;
            const oz = cz - n.z;
            const dist2 = ox * ox + oy * oy + oz * oz;
            if (dist2 >= rr * rr) continue;
            const dist = Math.sqrt(Math.max(1e-10, dist2));
            const nx = ox / dist;
            const ny = oy / dist;
            const nz = oz / dist;
            if (!hit || t < bestT) {
              hit = true;
              bestT = t;
              hitNx = nx;
              hitNy = ny;
              hitNz = nz;
            }
          }
        }

        if (!hit) return;

        const hx = sx + dx * bestT;
        const hy = sy + dy * bestT;
        const hz = sz + dz * bestT;
        // Make sure normal opposes motion, so resolution keeps ball on the incoming side.
        if (hitNx * dx + hitNy * dy + hitNz * dz > 0) {
          hitNx = -hitNx;
          hitNy = -hitNy;
          hitNz = -hitNz;
        }
        ball.x = hx + hitNx * (rr + 0.02);
        ball.y = hy + hitNy * (rr + 0.02);
        ball.z = hz + hitNz * (rr + 0.02);

        const vn = ball.vx * hitNx + ball.vy * hitNy + ball.vz * hitNz;
        if (vn < 0) {
          ball.vx -= hitNx * vn;
          ball.vy -= hitNy * vn;
          ball.vz -= hitNz * vn;
        }
        ball.vx *= 0.99;
        ball.vy *= 0.99;
        ball.vz *= 0.99;

        // Transfer impact impulse to nearby cloth nodes so the curtain visibly reacts.
        const impact = Math.max(0, -(ball.vx * hitNx + ball.vy * hitNy + ball.vz * hitNz));
        const radius = ball.r * 4.4;
        const radius2 = radius * radius;
        const pushBase = clamp(impact * 0.04, 0.08, 0.5);
        for (const n of cloth.nodes) {
          if (n.invMass <= 0) continue;
          const dxn = n.x - hx;
          const dyn = n.y - hy;
          const dzn = n.z - hz;
          const d2 = dxn * dxn + dyn * dyn + dzn * dzn;
          if (d2 > radius2) continue;
          const w = 1 - Math.sqrt(d2) / radius;
          const push = pushBase * w * w;
          n.x += hitNx * push * 1.45;
          n.y += hitNy * push * 1.45;
          n.z += hitNz * push * 1.45;
          // Verlet velocity injection: move previous position backward along impulse.
          n.px -= hitNx * push * 1.35;
          n.py -= hitNy * push * 1.35;
          n.pz -= hitNz * push * 1.35;
        }
      }

      function updateCloth(dt) {
        const cloth = state.cloth;
        if (!cloth) return;
        const simDt = Math.min(0.05, dt * clothSetup.timeStepScale);
        const stepDt = simDt / clothSetup.substeps;
        const damp = 1 - clothSetup.damping;
        for (let s = 0; s < clothSetup.substeps; s++) {
          for (const n of cloth.nodes) {
            if (n.invMass <= 0) continue;
            const vx = (n.x - n.px) * damp;
            const vy = (n.y - n.py) * damp;
            const vz = (n.z - n.pz) * damp;
            n.px = n.x;
            n.py = n.y;
            n.pz = n.z;
            n.x += vx;
            n.y += vy + world.gravity * clothSetup.gravityScale * stepDt * stepDt;
            n.z += vz;
          }

          for (const c of cloth.constraints) c.lambda = 0;
          for (let i = 0; i < clothSetup.iterations; i++) {
            solveClothConstraints(stepDt);
            solveClothBallCollision(false);
            solveClothGroundCollision();
          }
        }
        solveClothBallCollision(true);
      }

      function pointerPos(e) {
        const p = e.touches ? e.touches[0] : e;
        return { x: p.clientX, y: p.clientY };
      }
      function clampMag(x, y, max) {
        const m = Math.hypot(x, y);
        if (m <= max || m === 0) return { x, y };
        const k = max / m;
        return { x: x * k, y: y * k };
      }
      function isFireLocked() {
        return state.gameOver;
      }

      function spawnBall(x, y, z, vx, vy, vz) {
        let activeCount = 0;
        for (const b of state.balls) {
          if (b && b.alive && !b.stopped) activeCount++;
        }
        if (activeCount >= PERF.maxActiveBalls) return;
        state.balls.push({ x, y, z, vx, vy, vz, r: 0.28, mass: 3.2, alive: true, stopped: false, hitCd: 0, hitTarget: false, missCounted: false });
      }
      function stopBall(ball) {
        ball.stopped = true;
        ball.vx = 0;
        ball.vy = 0;
        ball.vz = 0;
      }

      function spawnBallFragments(ball) {
        const count = PERF.fragmentCount;
        for (let i = 0; i < count; i++) {
          const dir = normalize3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
          const speed = 3 + Math.random() * 6;
          state.fragments.push({
            x: ball.x,
            y: ball.y,
            z: ball.z,
            vx: ball.vx * 0.25 + dir.x * speed,
            vy: ball.vy * 0.2 + Math.abs(dir.y) * speed * 0.9,
            vz: ball.vz * 0.25 + dir.z * speed,
            r: 0.05 + Math.random() * 0.05,
            life: 0.95 + Math.random() * 0.55,
          });
        }
      }
      function targetRadiusFromHp(target) {
        const hp01 = target.maxHp > 0 ? clamp(target.hp / target.maxHp, 0, 1) : 0;
        return target.baseR * (0.65 + 0.35 * hp01);
      }

      function onDown(e) {
        tryStartBgm(false);
        if (isFireLocked()) {
          state.drag.active = false;
          return;
        }
        e.preventDefault();
        const p = pointerPos(e);
        state.drag.active = true;
        state.drag.x = p.x;
        state.drag.y = p.y;
      }

      function onMove(e) {
        if (isFireLocked()) return;
        if (!state.drag.active) return;
        e.preventDefault();
        const p = pointerPos(e);
        state.drag.x = p.x;
        state.drag.y = p.y;

        const gunScr = worldToScreen(state.gun.x, state.gun.y, state.gun.z);
        if (!gunScr.ok) return;
        const dx = p.x - gunScr.sx;
        const dy = p.y - gunScr.sy;
        const c = clampMag(dx, dy, 260);
        const mag01 = Math.hypot(c.x, c.y) / 260;

        state.aim.yaw = clamp((-c.x / 260) * 1.0, -0.95, 0.95);
        state.aim.pitch = clamp(0.22 + (-c.y / 260) * 0.9, -0.1, 0.95);
        state.aim.power = clamp(0.2 + mag01 * 0.8, 0.2, 1.0);
      }

      function onUp(e) {
        tryStartBgm(false);
        if (isFireLocked()) {
          state.drag.active = false;
          return;
        }
        if (!state.drag.active) return;
        e.preventDefault();
        state.drag.active = false;
        if (hitFireRateLimit()) return;

        const shot = getAimShot();
        const pose = getGunPose();
        spawnBall(pose.muzzle.x, pose.muzzle.y, pose.muzzle.z, shot.dir.x * shot.speed, shot.dir.y * shot.speed, shot.dir.z * shot.speed);
      }

      function update(dt, t) {
        updateCloth(dt);

        for (const target of state.targets) {
          target.r = targetRadiusFromHp(target);
          if (!target.dead) {
            target.anchorX = target.baseX + Math.sin(t * target.wx + target.phase) * target.sx;
            const rawTopY = target.baseY + Math.cos(t * target.wy + target.phase * 1.3) * target.sy + target.r;
            const minTopY = target.r * 2 + 0.12;
            target.anchorY = Math.max(rawTopY, minTopY);

            const topX = target.x;
            const topY = target.y + target.r;
            const dx = target.anchorX - topX;
            const dy = target.anchorY - topY;
            const ax = world.targetSpring * dx - world.targetDamping * target.vx;
            const ay = world.targetSpring * dy - world.targetDamping * target.vy + world.targetGravity;

            target.vx += ax * dt;
            target.vy += ay * dt;
            target.vx *= 0.995;
            target.vy *= 0.995;
            target.x += target.vx * dt;
            target.y += target.vy * dt;
          } else {
            target.vy += world.gravity * dt;
            target.vx *= 0.998;
            target.vy *= 0.998;
            target.vz *= 0.998;
            target.avX *= 0.9975;
            target.avY *= 0.996;
            target.avZ *= 0.9975;
            target.x += target.vx * dt;
            target.y += target.vy * dt;
            target.z += target.vz * dt;
            target.rotX += target.avX * dt;
            target.rotY += target.avY * dt;
            target.rotZ += target.avZ * dt;

            // 持续重力翻倒扭矩，避免圆盘总是“立着蹦”。
            const n = targetNormal(target);
            const tipTorque = 4.2;
            target.avX += n.z * tipTorque * dt;
            target.avZ += -n.x * tipTorque * dt;

            const support = targetSupportRadiusY(target);
            if (target.y - support < 0) {
              target.y = support;
              target.vy = Math.abs(target.vy) * 0.22;
              target.vx *= 0.82;
              target.vz *= 0.82;
              target.avX += target.vz * 0.12 + (Math.random() - 0.5) * 0.35;
              target.avZ -= target.vx * 0.12 + (Math.random() - 0.5) * 0.35;

              const tilt = Math.hypot(target.rotX, target.rotZ);
              if (tilt < 1.25) {
                target.avX += (Math.sign(target.rotX || 1) * 1.6 + (Math.random() - 0.5) * 0.4) * dt * 60;
                target.avZ += (Math.sign(target.rotZ || -1) * 1.6 + (Math.random() - 0.5) * 0.4) * dt * 60;
              }
            }
          }
          target.hitTimer = Math.max(0, target.hitTimer - dt);
        }

        for (const ball of state.balls) {
          if (!ball.alive) continue;
          if (ball.stopped) continue;
          ball.hitCd = Math.max(0, ball.hitCd - dt);
          const substeps = Math.max(1, clothSetup.ballCcdSubsteps | 0);
          const subDt = dt / substeps;
          const dragStep = Math.pow(world.drag, 1 / substeps);

          for (let s = 0; s < substeps; s++) {
            if (!ball.alive || ball.stopped) break;
            const prev = { x: ball.x, y: ball.y, z: ball.z };
            ball.vy += world.gravity * subDt;
            ball.vx *= dragStep;
            ball.vy *= dragStep;
            ball.vz *= dragStep;

            ball.x += ball.vx * subDt;
            ball.y += ball.vy * subDt;
            ball.z += ball.vz * subDt;

            resolveBallClothSweep(ball, prev);

            if (ball.y - ball.r < 0) {
              ball.y = ball.r;
              ball.vy = Math.abs(ball.vy) * world.bounce;
              ball.vx *= world.groundFriction;
              ball.vz *= world.groundFriction;
              if (Math.abs(ball.vy) < 1.7 && Math.hypot(ball.vx, ball.vz) < 1.4) {
                stopBall(ball);
                if (!ball.hitTarget && !ball.missCounted) {
                  ball.missCounted = true;
                  registerMissedShot();
                }
              }
            }

            if (!ball.stopped && ball.y <= ball.r + 0.03 && Math.hypot(ball.vx, ball.vy, ball.vz) < 1.9) {
              stopBall(ball);
              if (!ball.hitTarget && !ball.missCounted) {
                ball.missCounted = true;
                registerMissedShot();
              }
            }

            if (ball.x - ball.r < -7) {
              ball.x = -7 + ball.r;
              ball.vx = Math.abs(ball.vx) * world.wallBounce;
            } else if (ball.x + ball.r > 7) {
              ball.x = 7 - ball.r;
              ball.vx = -Math.abs(ball.vx) * world.wallBounce;
            }
          }

          for (const target of state.targets) {
            if (target.dead) continue;
            const dx = ball.x - target.x;
            const dy = ball.y - target.y;
            const dz = ball.z - target.z;
            const rr = ball.r + target.r;
            const d2 = dx * dx + dy * dy + dz * dz;
            if (d2 > rr * rr) continue;

            const d = Math.sqrt(d2) || 0.0001;
            const nx = dx / d;
            const ny = dy / d;
            const nz = dz / d;
            const overlap = rr - d;

            ball.x += nx * overlap * 0.7;
            ball.y += ny * overlap * 0.7;
            ball.z += nz * overlap * 0.7;
            target.x -= nx * overlap * 0.3;
            target.y -= ny * overlap * 0.3;

            const rvx = ball.vx - target.vx;
            const rvy = ball.vy - target.vy;
            const rvz = ball.vz;
            const vn = rvx * nx + rvy * ny + rvz * nz;
            if (vn >= 0) continue;

            const restitution = 0.65;
            const invBall = 1.0 / Math.max(0.0001, ball.mass || 1);
            const invTar = 1.0 / target.mass;
            const j = (-(1 + restitution) * vn) / (invBall + invTar);

            ball.vx += j * nx * invBall;
            ball.vy += j * ny * invBall;
            ball.vz += j * nz * invBall;

            target.vx -= j * nx * invTar;
            target.vy -= j * ny * invTar;

            if (ball.hitCd <= 0 && vn < -3.5) {
              const speed = Math.hypot(ball.vx, ball.vy, ball.vz);
              const impact = Math.max(0, -vn);
              const damage = impact * 3.2 + speed * 0.75;
              target.hp = Math.max(0, target.hp - damage);
              target.hitTimer = 0.25;
              target.hitTaunt = nextTargetHitTauntLine();
              target.hitTauntUntil = performance.now() * 0.001 + TARGET_HIT_TAUNT_SEC;
              state.score += 1;
              state.consecutiveMissShots = 0;
              ball.hitCd = 0.08;
              if (target.hp <= 0) {
                state.gameOver = true;
                state.gameOverText = `游戏结束：${target.portrait.name} 被击倒`;
                state.drag.active = false;
                target.dead = true;
                target.vx = target.vx - j * nx * invTar * 0.6;
                target.vy = Math.min(0, target.vy - j * ny * invTar);
                target.vz = -j * nz * invTar;
                target.rotX = (0.24 + Math.random() * 0.32) * (Math.random() > 0.5 ? 1 : -1);
                target.rotZ = (0.24 + Math.random() * 0.32) * (Math.random() > 0.5 ? 1 : -1);
                target.avX = (2.2 + Math.random() * 2.0) * (Math.random() > 0.5 ? 1 : -1) + target.vz * 0.08;
                target.avY = (Math.random() - 0.5) * 1.2;
                target.avZ = (2.2 + Math.random() * 2.0) * (Math.random() > 0.5 ? 1 : -1) - target.vx * 0.08;
                state.announceSrc = target.portrait.src;
                state.announceName = target.portrait.name;
                showAnnouncement(target.portrait.src);
              }
            }
            // 子弹命中任意目标后碎裂并销毁，防止重复击打。
            ball.hitTarget = true;
            spawnBallFragments(ball);
            ball.alive = false;
            break;
          }
        }

        for (const b of state.balls) {
          if (b.stopped) continue;
          const removedByRange = !(b.z < 42 && b.y > -2);
          const removedByDeath = !b.alive;
          if ((removedByRange || removedByDeath) && !b.hitTarget && !b.missCounted) {
            b.missCounted = true;
            registerMissedShot();
          }
        }

        for (const f of state.fragments) {
          f.life -= dt;
          f.vy += world.gravity * dt;
          f.vx *= 0.992;
          f.vy *= 0.992;
          f.vz *= 0.992;
          f.x += f.vx * dt;
          f.y += f.vy * dt;
          f.z += f.vz * dt;

          if (f.y - f.r < 0) {
            f.y = f.r;
            f.vy = Math.abs(f.vy) * 0.34;
            f.vx *= 0.86;
            f.vz *= 0.86;
          }
        }

        state.balls = state.balls.filter((b) => b.stopped || (b.alive && b.z < 42 && b.y > -2));
        state.fragments = state.fragments.filter((f) => f.life > 0 && f.z < 42 && f.y > -2);
      }

      function normalize3(x, y, z) {
        const m = Math.hypot(x, y, z) || 1;
        return { x: x / m, y: y / m, z: z / m };
      }
      function add3(a, b) {
        return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
      }
      function sub3(a, b) {
        return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
      }
      function mul3(a, s) {
        return { x: a.x * s, y: a.y * s, z: a.z * s };
      }
      function dot3(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
      }
      function cross3(a, b) {
        return {
          x: a.y * b.z - a.z * b.y,
          y: a.z * b.x - a.x * b.z,
          z: a.x * b.y - a.y * b.x,
        };
      }
      function targetThickness(target) {
        return Math.max(0.26, target.r * 0.42);
      }
      function rotateVecEuler(v, rotX, rotY, rotZ) {
        const cx = Math.cos(rotX), sx = Math.sin(rotX);
        const cy = Math.cos(rotY), sy = Math.sin(rotY);
        const cz = Math.cos(rotZ), sz = Math.sin(rotZ);

        const y1 = v.y * cx - v.z * sx;
        const z1 = v.y * sx + v.z * cx;
        const x1 = v.x;

        const x2 = x1 * cz - y1 * sz;
        const y2 = x1 * sz + y1 * cz;
        const z2 = z1;

        return {
          x: x2 * cy + z2 * sy,
          y: y2,
          z: -x2 * sy + z2 * cy,
        };
      }
      function targetRotateVec(target, v) {
        return rotateVecEuler(v, target.rotX || 0, target.rotY || 0, target.rotZ || 0);
      }
      function targetLocalToWorld(target, lx, ly, lz) {
        const p = targetRotateVec(target, { x: lx, y: ly, z: lz });
        return { x: target.x + p.x, y: target.y + p.y, z: target.z + p.z };
      }
      function targetNormal(target) {
        return normalize3(
          targetRotateVec(target, { x: 0, y: 0, z: 1 }).x,
          targetRotateVec(target, { x: 0, y: 0, z: 1 }).y,
          targetRotateVec(target, { x: 0, y: 0, z: 1 }).z
        );
      }
      function targetSupportRadiusY(target) {
        const n = targetNormal(target);
        const h = targetThickness(target) * 0.5;
        const ring = target.r * Math.sqrt(Math.max(0, 1 - n.y * n.y));
        const cap = h * Math.abs(n.y);
        return ring + cap;
      }

      function identity4() {
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      function mul4(a, b) {
        const o = new Float32Array(16);
        for (let c = 0; c < 4; c++) {
          for (let r = 0; r < 4; r++) {
            o[c * 4 + r] =
              a[0 * 4 + r] * b[c * 4 + 0] +
              a[1 * 4 + r] * b[c * 4 + 1] +
              a[2 * 4 + r] * b[c * 4 + 2] +
              a[3 * 4 + r] * b[c * 4 + 3];
          }
        }
        return o;
      }
      function perspective4(fovY, aspect, near, far) {
        const f = 1.0 / Math.tan(fovY * 0.5);
        const nf = 1.0 / (near - far);
        return new Float32Array([
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0,
        ]);
      }
      function lookAt4(eye, target, up) {
        const z = normalize3(eye.x - target.x, eye.y - target.y, eye.z - target.z);
        const x = normalize3(cross3(up, z).x, cross3(up, z).y, cross3(up, z).z);
        const y = cross3(z, x);
        return new Float32Array([
          x.x,
          y.x,
          z.x,
          0,
          x.y,
          y.y,
          z.y,
          0,
          x.z,
          y.z,
          z.z,
          0,
          -dot3(x, eye),
          -dot3(y, eye),
          -dot3(z, eye),
          1,
        ]);
      }
      function mulMat4Vec4(m, v) {
        return {
          x: m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12] * v.w,
          y: m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13] * v.w,
          z: m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14] * v.w,
          w: m[3] * v.x + m[7] * v.y + m[11] * v.z + m[15] * v.w,
        };
      }
      function updateViewProj() {
        const aspect = Math.max(0.1, canvas.width / canvas.height);
        const proj = perspective4(cam.fovY, aspect, cam.near, cam.far);
        const view = lookAt4(cam.pos, cam.target, cam.up);
        state.viewProj = mul4(proj, view);
      }
      function worldToScreen(x, y, z) {
        const c = mulMat4Vec4(state.viewProj, { x, y, z, w: 1 });
        if (c.w <= 0.0001) return { ok: false };
        const ndcX = c.x / c.w;
        const ndcY = c.y / c.w;
        const sx = (ndcX * 0.5 + 0.5) * state.screenW;
        const sy = (1 - (ndcY * 0.5 + 0.5)) * state.screenH;
        return { ok: true, sx, sy, ndcZ: c.z / c.w };
      }

      function getAimShot() {
        const cosP = Math.cos(state.aim.pitch);
        const dir = normalize3(Math.sin(state.aim.yaw) * cosP, Math.sin(state.aim.pitch), Math.cos(state.aim.yaw) * cosP);
        const speed = 42 + state.aim.power * 48;
        return { dir, speed };
      }
      function getGunPose() {
        const { dir } = getAimShot();
        const rightRaw = cross3(dir, { x: 0, y: 1, z: 0 });
        let right = normalize3(rightRaw.x, rightRaw.y, rightRaw.z);
        if (Math.hypot(right.x, right.y, right.z) < 0.0001) right = { x: 1, y: 0, z: 0 };
        const upRaw = cross3(right, dir);
        const up = normalize3(upRaw.x, upRaw.y, upRaw.z);
        const gun = { x: state.gun.x, y: state.gun.y, z: state.gun.z };
        const receiverCenter = add3(gun, add3(mul3(dir, 0.65), mul3(up, 0.08)));
        const barrelCenter = add3(gun, add3(mul3(dir, 1.95), mul3(up, 0.11)));
        const muzzle = add3(barrelCenter, mul3(dir, 1.35));
        return { gun, dir, right, up, receiverCenter, barrelCenter, muzzle };
      }

      function pushMeshVertex(arr, p, n, c) {
        arr.push(p.x, p.y, p.z, n.x, n.y, n.z, c[0], c[1], c[2], c[3] == null ? 1 : c[3]);
      }
      function pushMeshTri(arr, p1, n1, c1, p2, n2, c2, p3, n3, c3) {
        pushMeshVertex(arr, p1, n1, c1);
        pushMeshVertex(arr, p2, n2, c2);
        pushMeshVertex(arr, p3, n3, c3);
      }
      function pushMeshQuad(arr, p1, n1, c1, p2, n2, c2, p3, n3, c3, p4, n4, c4) {
        pushMeshTri(arr, p1, n1, c1, p2, n2, c2, p3, n3, c3);
        pushMeshTri(arr, p1, n1, c1, p3, n3, c3, p4, n4, c4);
      }

      function pushTexVertex(arr, p, n, c, uv) {
        arr.push(p.x, p.y, p.z, n.x, n.y, n.z, c[0], c[1], c[2], c[3] == null ? 1 : c[3], uv[0], uv[1]);
      }
      function pushTexTri(arr, p1, n1, c1, uv1, p2, n2, c2, uv2, p3, n3, c3, uv3) {
        pushTexVertex(arr, p1, n1, c1, uv1);
        pushTexVertex(arr, p2, n2, c2, uv2);
        pushTexVertex(arr, p3, n3, c3, uv3);
      }

      function addPrismMesh(arr, center, axisDir, length, width, height, col) {
        const axis = normalize3(axisDir.x, axisDir.y, axisDir.z);
        let refUp = { x: 0, y: 1, z: 0 };
        if (Math.abs(dot3(axis, refUp)) > 0.93) refUp = { x: 1, y: 0, z: 0 };
        const right = normalize3(cross3(axis, refUp).x, cross3(axis, refUp).y, cross3(axis, refUp).z);
        const up = normalize3(cross3(right, axis).x, cross3(right, axis).y, cross3(right, axis).z);

        const hf = length * 0.5;
        const hw = width * 0.5;
        const hh = height * 0.5;
        const p = (f, rw, uh) => add3(add3(center, mul3(axis, f * hf)), add3(mul3(right, rw * hw), mul3(up, uh * hh)));

        const F1 = p(1, -1, -1), F2 = p(1, 1, -1), F3 = p(1, 1, 1), F4 = p(1, -1, 1);
        const B1 = p(-1, -1, -1), B2 = p(-1, 1, -1), B3 = p(-1, 1, 1), B4 = p(-1, -1, 1);

        pushMeshQuad(arr, F1, axis, col, F2, axis, col, F3, axis, col, F4, axis, col);
        pushMeshQuad(arr, B2, mul3(axis, -1), col, B1, mul3(axis, -1), col, B4, mul3(axis, -1), col, B3, mul3(axis, -1), col);
        pushMeshQuad(arr, B1, mul3(right, -1), col, F1, mul3(right, -1), col, F4, mul3(right, -1), col, B4, mul3(right, -1), col);
        pushMeshQuad(arr, F2, right, col, B2, right, col, B3, right, col, F3, right, col);
        pushMeshQuad(arr, B4, up, col, F4, up, col, F3, up, col, B3, up, col);
        pushMeshQuad(arr, B1, mul3(up, -1), col, B2, mul3(up, -1), col, F2, mul3(up, -1), col, F1, mul3(up, -1), col);
      }

      function addSphereMesh(arr, c, r, col, stacks = 10, slices = 16) {
        for (let i = 0; i < stacks; i++) {
          const v0 = i / stacks;
          const v1 = (i + 1) / stacks;
          const t0 = v0 * Math.PI;
          const t1 = v1 * Math.PI;
          for (let j = 0; j < slices; j++) {
            const u0 = (j / slices) * Math.PI * 2;
            const u1 = ((j + 1) / slices) * Math.PI * 2;
            const n00 = { x: Math.sin(t0) * Math.cos(u0), y: Math.cos(t0), z: Math.sin(t0) * Math.sin(u0) };
            const n10 = { x: Math.sin(t1) * Math.cos(u0), y: Math.cos(t1), z: Math.sin(t1) * Math.sin(u0) };
            const n11 = { x: Math.sin(t1) * Math.cos(u1), y: Math.cos(t1), z: Math.sin(t1) * Math.sin(u1) };
            const n01 = { x: Math.sin(t0) * Math.cos(u1), y: Math.cos(t0), z: Math.sin(t0) * Math.sin(u1) };
            const p00 = add3(c, mul3(n00, r));
            const p10 = add3(c, mul3(n10, r));
            const p11 = add3(c, mul3(n11, r));
            const p01 = add3(c, mul3(n01, r));
            pushMeshTri(arr, p00, n00, col, p10, n10, col, p11, n11, col);
            pushMeshTri(arr, p00, n00, col, p11, n11, col, p01, n01, col);
          }
        }
      }

      function addGround(meshArr) {
        const xMin = -9;
        const xMax = 9;
        const zNear = -3;
        const zFar = 35;
        const base = [0.46, 0.31, 0.19, 1.0];

        pushMeshQuad(
          meshArr,
          { x: xMin, y: 0, z: zNear },
          { x: 0, y: 1, z: 0 },
          base,
          { x: xMax, y: 0, z: zNear },
          { x: 0, y: 1, z: 0 },
          base,
          { x: xMax, y: 0, z: zFar },
          { x: 0, y: 1, z: 0 },
          base,
          { x: xMin, y: 0, z: zFar },
          { x: 0, y: 1, z: 0 },
          base
        );

        const lineCol = [0.62, 0.45, 0.29, 0.9];
        for (let z = 2; z <= 34; z += 2) {
          addGroundLine(meshArr, { x: -8, y: 0.015, z }, { x: 8, y: 0.015, z }, 0.025, lineCol);
        }
        for (let x = -8; x <= 8; x += 1.5) {
          addGroundLine(meshArr, { x, y: 0.015, z: 2 }, { x, y: 0.015, z: 34 }, 0.025, lineCol);
        }
      }
      function addClothMesh(meshArr) {
        const cloth = state.cloth;
        if (!cloth) return;
        const base = [0.34, 0.04, 0.07, 1.0];
        const nodeAt = (x, y) => cloth.nodes[clamp(x, 0, cloth.cols - 1) + clamp(y, 0, cloth.rows - 1) * cloth.cols];
        const nodeNormal = (x, y) => {
          const l = nodeAt(x - 1, y);
          const r = nodeAt(x + 1, y);
          const u = nodeAt(x, y - 1);
          const d = nodeAt(x, y + 1);
          const tx = sub3(r, l);
          const ty = sub3(d, u);
          let n = normalize3(cross3(tx, ty).x, cross3(tx, ty).y, cross3(tx, ty).z);
          if (!Number.isFinite(n.x) || !Number.isFinite(n.y) || !Number.isFinite(n.z)) n = { x: 0, y: 0, z: -1 };
          return n;
        };
        for (let y = 0; y < cloth.rows - 1; y++) {
          for (let x = 0; x < cloth.cols - 1; x++) {
            const i00 = x + y * cloth.cols;
            const i10 = i00 + 1;
            const i01 = i00 + cloth.cols;
            const i11 = i01 + 1;
            const p00 = cloth.nodes[i00];
            const p10 = cloth.nodes[i10];
            const p01 = cloth.nodes[i01];
            const p11 = cloth.nodes[i11];
            const n00 = nodeNormal(x, y);
            const n10 = nodeNormal(x + 1, y);
            const n01 = nodeNormal(x, y + 1);
            const n11 = nodeNormal(x + 1, y + 1);

            const stripe = 0.9 + 0.1 * Math.sin((x / cloth.cols) * Math.PI * 7);
            const col = [base[0] * stripe, base[1] * stripe, base[2] * stripe, 1];

            pushMeshTri(meshArr, p00, n00, col, p01, n01, col, p11, n11, col);
            pushMeshTri(meshArr, p00, n00, col, p11, n11, col, p10, n10, col);
          }
        }

        if (cloth.rivetCols && cloth.rivetCols.length) {
          for (const rx of cloth.rivetCols) {
            const n = cloth.nodes[rx];
            if (!n) continue;
            addSphereMesh(meshArr, { x: n.x, y: n.y, z: n.z - 0.03 }, 0.11, [0.78, 0.8, 0.86, 1], 8, 12);
          }
        }
      }
      function addGroundLine(arr, a, b, w, col) {
        const d = sub3(b, a);
        const len = Math.hypot(d.x, d.y, d.z) || 1;
        const dir = { x: d.x / len, y: d.y / len, z: d.z / len };
        const right = normalize3(-dir.z, 0, dir.x);
        const off = mul3(right, w * 0.5);
        const p1 = add3(a, off);
        const p2 = add3(b, off);
        const p3 = sub3(b, off);
        const p4 = sub3(a, off);
        const n = { x: 0, y: 1, z: 0 };
        pushMeshQuad(arr, p1, n, col, p2, n, col, p3, n, col, p4, n, col);
      }

      function addTargetShadow(arr, target) {
        const ldir = normalize3(directionalLight.dir.x, directionalLight.dir.y, directionalLight.dir.z);
        const t = target.y / Math.max(0.0001, -ldir.y);
        const c = { x: target.x + ldir.x * t, y: 0.02, z: target.z + ldir.z * t };
        const shadowR = target.r * (1.2 + Math.max(0.6, target.y) * 0.22);
        const seg = 22;
        const col = [0.1, 0.11, 0.14, 0.24];
        for (let i = 0; i < seg; i++) {
          const a0 = (i / seg) * Math.PI * 2;
          const a1 = ((i + 1) / seg) * Math.PI * 2;
          const p0 = { x: c.x + Math.cos(a0) * shadowR, y: c.y, z: c.z + Math.sin(a0) * shadowR };
          const p1 = { x: c.x + Math.cos(a1) * shadowR, y: c.y, z: c.z + Math.sin(a1) * shadowR };
          const n = { x: 0, y: 1, z: 0 };
          pushMeshTri(arr, c, n, col, p0, n, col, p1, n, col);
        }
      }

      function addTargetGeometry(meshArr, target) {
        const seg = 36;
        const thickness = targetThickness(target);
        const half = thickness * 0.5;
        const hp01 = target.maxHp > 0 ? target.hp / target.maxHp : 0;

        const bodyCol = target.hitTimer > 0 ? [0.95, 0.45, 0.34, 1] : [0.72, 0.46 + hp01 * 0.14, 0.38 + hp01 * 0.1, 1];
        const sideCol = [bodyCol[0] * 0.64, bodyCol[1] * 0.64, bodyCol[2] * 0.64, 1];
        const backCol = [bodyCol[0] * 0.52, bodyCol[1] * 0.52, bodyCol[2] * 0.52, 1];

        for (let i = 0; i < seg; i++) {
          const a0 = (i / seg) * Math.PI * 2;
          const a1 = ((i + 1) / seg) * Math.PI * 2;
          const nx0 = Math.cos(a0);
          const ny0 = Math.sin(a0);
          const nx1 = Math.cos(a1);
          const ny1 = Math.sin(a1);

          const pF0 = targetLocalToWorld(target, nx0 * target.r, ny0 * target.r, -half);
          const pF1 = targetLocalToWorld(target, nx1 * target.r, ny1 * target.r, -half);
          const pB0 = targetLocalToWorld(target, nx0 * target.r, ny0 * target.r, half);
          const pB1 = targetLocalToWorld(target, nx1 * target.r, ny1 * target.r, half);
          const n0 = normalize3(
            targetRotateVec(target, { x: nx0, y: ny0, z: 0 }).x,
            targetRotateVec(target, { x: nx0, y: ny0, z: 0 }).y,
            targetRotateVec(target, { x: nx0, y: ny0, z: 0 }).z
          );
          const n1 = normalize3(
            targetRotateVec(target, { x: nx1, y: ny1, z: 0 }).x,
            targetRotateVec(target, { x: nx1, y: ny1, z: 0 }).y,
            targetRotateVec(target, { x: nx1, y: ny1, z: 0 }).z
          );
          pushMeshQuad(meshArr, pF0, n0, sideCol, pB0, n0, sideCol, pB1, n1, sideCol, pF1, n1, sideCol);

          const cBack = targetLocalToWorld(target, 0, 0, half);
          const nBack = normalize3(
            targetRotateVec(target, { x: 0, y: 0, z: 1 }).x,
            targetRotateVec(target, { x: 0, y: 0, z: 1 }).y,
            targetRotateVec(target, { x: 0, y: 0, z: 1 }).z
          );
          pushMeshTri(meshArr, cBack, nBack, backCol, pB1, nBack, backCol, pB0, nBack, backCol);
        }

        const rimCol = [0.96, 0.96, 0.96, 1];
        const rimOuter = target.r * 1.05;
        const rimInner = target.r * 0.985;
        const nRim = normalize3(
          targetRotateVec(target, { x: 0, y: 0, z: -1 }).x,
          targetRotateVec(target, { x: 0, y: 0, z: -1 }).y,
          targetRotateVec(target, { x: 0, y: 0, z: -1 }).z
        );
        for (let i = 0; i < seg; i++) {
          const a0 = (i / seg) * Math.PI * 2;
          const a1 = ((i + 1) / seg) * Math.PI * 2;
          const o0 = targetLocalToWorld(target, Math.cos(a0) * rimOuter, Math.sin(a0) * rimOuter, -half - 0.002);
          const o1 = targetLocalToWorld(target, Math.cos(a1) * rimOuter, Math.sin(a1) * rimOuter, -half - 0.002);
          const i0 = targetLocalToWorld(target, Math.cos(a0) * rimInner, Math.sin(a0) * rimInner, -half - 0.002);
          const i1 = targetLocalToWorld(target, Math.cos(a1) * rimInner, Math.sin(a1) * rimInner, -half - 0.002);
          pushMeshQuad(meshArr, o0, nRim, rimCol, o1, nRim, rimCol, i1, nRim, rimCol, i0, nRim, rimCol);
        }
      }

      function addGun(meshArr) {
        const pose = getGunPose();
        const dir = pose.dir;
        const right = pose.right;
        const up = pose.up;
        const gun = pose.gun;
        const receiverCenter = pose.receiverCenter;
        const barrelCenter = pose.barrelCenter;
        const gripAxis = normalize3(dir.x * 0.2, -0.95, dir.z * 0.2);
        const gripCenter = add3(gun, add3(mul3(dir, -0.2), mul3(up, -0.68)));
        const metalDark = [0.17, 0.2, 0.27, 1];
        const metalLight = [0.3, 0.36, 0.45, 1];
        const accent = [0.46, 0.5, 0.6, 1];
        const wood = [0.38, 0.24, 0.16, 1];
        const polymer = [0.11, 0.13, 0.16, 1];

        // Receiver and top rail.
        addPrismMesh(meshArr, receiverCenter, dir, 1.85, 0.56, 0.38, metalDark);
        addPrismMesh(meshArr, add3(receiverCenter, mul3(up, 0.23)), dir, 1.55, 0.34, 0.08, accent);

        // Barrel assembly + muzzle.
        addPrismMesh(meshArr, barrelCenter, dir, 2.65, 0.24, 0.2, metalLight);
        addPrismMesh(meshArr, add3(barrelCenter, mul3(dir, 1.38)), dir, 0.24, 0.3, 0.26, metalDark);
        addPrismMesh(meshArr, add3(barrelCenter, mul3(dir, 0.45)), dir, 1.0, 0.32, 0.28, polymer);

        // Front guard and rear stock block.
        const guardCenter = add3(gun, add3(mul3(dir, 0.15), mul3(up, -0.2)));
        addPrismMesh(meshArr, guardCenter, dir, 0.62, 0.22, 0.12, polymer);
        addPrismMesh(meshArr, add3(receiverCenter, add3(mul3(dir, -1.0), mul3(up, -0.08))), dir, 0.95, 0.46, 0.34, wood);

        // Grip + butt pad.
        addPrismMesh(meshArr, gripCenter, gripAxis, 1.35, 0.34, 0.56, wood);
        addPrismMesh(meshArr, add3(gripCenter, mul3(gripAxis, -0.72)), gripAxis, 0.22, 0.4, 0.6, polymer);

        // Sights.
        const sightBack = add3(receiverCenter, add3(mul3(dir, 0.52), mul3(up, 0.3)));
        const sightFront = add3(barrelCenter, add3(mul3(dir, 1.06), mul3(up, 0.27)));
        addPrismMesh(meshArr, sightBack, up, 0.17, 0.08, 0.14, accent);
        addPrismMesh(meshArr, sightFront, up, 0.22, 0.08, 0.17, accent);

        // Side cheek pieces to thicken silhouette.
        addPrismMesh(meshArr, add3(receiverCenter, mul3(right, 0.26)), dir, 1.1, 0.08, 0.24, metalDark);
        addPrismMesh(meshArr, add3(receiverCenter, mul3(right, -0.26)), dir, 1.1, 0.08, 0.24, metalDark);
      }

      function toClipX(x) {
        return (x / state.screenW) * 2 - 1;
      }
      function toClipY(y) {
        return 1 - (y / state.screenH) * 2;
      }
      function addLine2D(arr, x1, y1, x2, y2, w, c) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const m = Math.hypot(dx, dy) || 1;
        const nx = (-dy / m) * w * 0.5;
        const ny = (dx / m) * w * 0.5;
        const p1 = [toClipX(x1 + nx), toClipY(y1 + ny)];
        const p2 = [toClipX(x2 + nx), toClipY(y2 + ny)];
        const p3 = [toClipX(x2 - nx), toClipY(y2 - ny)];
        const p4 = [toClipX(x1 - nx), toClipY(y1 - ny)];
        pushLineTri(arr, p1, c, p2, c, p3, c);
        pushLineTri(arr, p1, c, p3, c, p4, c);
      }
      function pushLineTri(arr, p1, c1, p2, c2, p3, c3) {
        arr.push(p1[0], p1[1], c1[0], c1[1], c1[2], c1[3]);
        arr.push(p2[0], p2[1], c2[0], c2[1], c2[2], c2[3]);
        arr.push(p3[0], p3[1], c3[0], c3[1], c3[2], c3[3]);
      }

      function buildAimSegments() {
        if (!state.drag.active) return [];
        const shot = getAimShot();
        const pose = getGunPose();
        let p = { x: pose.muzzle.x, y: pose.muzzle.y, z: pose.muzzle.z };
        let v3 = { x: shot.dir.x * shot.speed, y: shot.dir.y * shot.speed, z: shot.dir.z * shot.speed };
        const dt = 0.07;
        const steps = PERF.aimSteps;
        const out = [];
        for (let i = 0; i < steps; i++) {
          const prev = { x: p.x, y: p.y, z: p.z };
          v3.y += world.gravity * dt;
          v3.x *= world.drag;
          v3.y *= world.drag;
          v3.z *= world.drag;
          p.x += v3.x * dt;
          p.y += v3.y * dt;
          p.z += v3.z * dt;
          if (p.y < 0) p.y = 0;
          const s0 = worldToScreen(prev.x, prev.y, prev.z);
          const s1 = worldToScreen(p.x, p.y, p.z);
          if (s0.ok && s1.ok) out.push({ x1: s0.sx, y1: s0.sy, x2: s1.sx, y2: s1.sy });
          if (p.y <= 0) break;
        }
        return out;
      }

      function renderScene() {
        updateViewProj();

        const meshVerts = [];
        const clothVerts = [];
        const shadowVerts = [];

        addGround(meshVerts);
        addClothMesh(clothVerts);

        for (const t of state.targets) {
          addTargetShadow(shadowVerts, t);
        }

        for (const b of state.balls) {
          if (!b.alive) continue;
          addSphereMesh(meshVerts, { x: b.x, y: b.y, z: b.z }, b.r, [0.82, 0.84, 0.88, 1], PERF.ballSphereLat, PERF.ballSphereLon);
        }
        for (const f of state.fragments) {
          addSphereMesh(meshVerts, { x: f.x, y: f.y, z: f.z }, f.r, [0.2, 0.22, 0.28, 1], PERF.fragmentSphereLat, PERF.fragmentSphereLon);
        }

        for (const t of state.targets) {
          if (!t.dead) {
            addTargetGeometry(meshVerts, t);
          } else {
            addTargetGeometry(meshVerts, t);
          }
        }

        addGun(meshVerts);

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clearDepth(1);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.disable(gl.CULL_FACE);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.useProgram(mesh.prog);
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
        gl.enableVertexAttribArray(mesh.aPos);
        gl.enableVertexAttribArray(mesh.aNrm);
        gl.enableVertexAttribArray(mesh.aCol);
        gl.vertexAttribPointer(mesh.aPos, 3, gl.FLOAT, false, 40, 0);
        gl.vertexAttribPointer(mesh.aNrm, 3, gl.FLOAT, false, 40, 12);
        gl.vertexAttribPointer(mesh.aCol, 4, gl.FLOAT, false, 40, 24);

        gl.uniformMatrix4fv(mesh.uViewProj, false, state.viewProj);
        gl.uniform3f(mesh.uCamPos, cam.pos.x, cam.pos.y, cam.pos.z);
        gl.uniform3f(mesh.uLightDir, directionalLight.dir.x, directionalLight.dir.y, directionalLight.dir.z);
        gl.uniform3f(mesh.uLightColor, directionalLight.color[0], directionalLight.color[1], directionalLight.color[2]);
        gl.uniform1f(mesh.uLightIntensity, directionalLight.intensity);
        gl.uniform3f(mesh.uAmbColor, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);
        gl.uniform1f(mesh.uAmbIntensity, ambientLight.intensity);
        gl.uniform1f(mesh.uShininess, 26);
        gl.uniform1f(mesh.uSpecStrength, 0.22);

        const meshData = new Float32Array(meshVerts);
        gl.bufferData(gl.ARRAY_BUFFER, meshData, gl.DYNAMIC_DRAW);
        gl.disable(gl.BLEND);
        gl.depthMask(true);
        gl.drawArrays(gl.TRIANGLES, 0, meshData.length / 10);

        if (clothVerts.length) {
          const clothData = new Float32Array(clothVerts);
          gl.bufferData(gl.ARRAY_BUFFER, clothData, gl.DYNAMIC_DRAW);
          gl.uniform1f(mesh.uShininess, 9);
          gl.uniform1f(mesh.uSpecStrength, 0.48);
          gl.drawArrays(gl.TRIANGLES, 0, clothData.length / 10);
          gl.uniform1f(mesh.uShininess, 26);
          gl.uniform1f(mesh.uSpecStrength, 0.22);
        }

        const texTargets = state.targets.filter((t) => t.portrait && t.portrait.loaded);
        gl.useProgram(tex.prog);
        gl.bindBuffer(gl.ARRAY_BUFFER, tex.vbo);
        gl.enableVertexAttribArray(tex.aPos);
        gl.enableVertexAttribArray(tex.aNrm);
        gl.enableVertexAttribArray(tex.aCol);
        gl.enableVertexAttribArray(tex.aUv);
        gl.vertexAttribPointer(tex.aPos, 3, gl.FLOAT, false, 48, 0);
        gl.vertexAttribPointer(tex.aNrm, 3, gl.FLOAT, false, 48, 12);
        gl.vertexAttribPointer(tex.aCol, 4, gl.FLOAT, false, 48, 24);
        gl.vertexAttribPointer(tex.aUv, 2, gl.FLOAT, false, 48, 40);

        gl.uniformMatrix4fv(tex.uViewProj, false, state.viewProj);
        gl.uniform3f(tex.uCamPos, cam.pos.x, cam.pos.y, cam.pos.z);
        gl.uniform3f(tex.uLightDir, directionalLight.dir.x, directionalLight.dir.y, directionalLight.dir.z);
        gl.uniform3f(tex.uLightColor, directionalLight.color[0], directionalLight.color[1], directionalLight.color[2]);
        gl.uniform1f(tex.uLightIntensity, directionalLight.intensity);
        gl.uniform3f(tex.uAmbColor, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);
        gl.uniform1f(tex.uAmbIntensity, ambientLight.intensity);
        gl.uniform1i(tex.uTex, 0);

        for (const t of texTargets) {
          const seg = PERF.targetDiscSeg;
          const thickness = targetThickness(t);
          const half = thickness * 0.5;
          const n = normalize3(
            targetRotateVec(t, { x: 0, y: 0, z: -1 }).x,
            targetRotateVec(t, { x: 0, y: 0, z: -1 }).y,
            targetRotateVec(t, { x: 0, y: 0, z: -1 }).z
          );
          const verts = [];
          for (let i = 0; i < seg; i++) {
            const a0 = (i / seg) * Math.PI * 2;
            const a1 = ((i + 1) / seg) * Math.PI * 2;
            const x0 = Math.cos(a0);
            const y0 = Math.sin(a0);
            const x1 = Math.cos(a1);
            const y1 = Math.sin(a1);
            const c = targetLocalToWorld(t, 0, 0, -half - 0.001);
            const p0 = targetLocalToWorld(t, x0 * t.r, y0 * t.r, -half - 0.001);
            const p1 = targetLocalToWorld(t, x1 * t.r, y1 * t.r, -half - 0.001);
            pushTexTri(verts, c, n, [1, 1, 1, 1], [0.5, 0.5], p0, n, [1, 1, 1, 1], [0.5 + x0 * 0.5, 0.5 + y0 * 0.5], p1, n, [1, 1, 1, 1], [0.5 + x1 * 0.5, 0.5 + y1 * 0.5]);
          }
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, t.portrait.tex);
          const hp01 = t.maxHp > 0 ? t.hp / t.maxHp : 0;
          gl.uniform1f(tex.uRedTint, clamp((1 - hp01) * 0.35, 0, 0.35));
          const data = new Float32Array(verts);
          gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, data.length / 12);
        }

        gl.useProgram(mesh.prog);
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
        gl.enableVertexAttribArray(mesh.aPos);
        gl.enableVertexAttribArray(mesh.aNrm);
        gl.enableVertexAttribArray(mesh.aCol);
        gl.vertexAttribPointer(mesh.aPos, 3, gl.FLOAT, false, 40, 0);
        gl.vertexAttribPointer(mesh.aNrm, 3, gl.FLOAT, false, 40, 12);
        gl.vertexAttribPointer(mesh.aCol, 4, gl.FLOAT, false, 40, 24);

        if (shadowVerts.length) {
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.depthMask(false);
          const shadowData = new Float32Array(shadowVerts);
          gl.bufferData(gl.ARRAY_BUFFER, shadowData, gl.DYNAMIC_DRAW);
          gl.uniform1f(mesh.uShininess, 8);
          gl.uniform1f(mesh.uSpecStrength, 0.03);
          gl.drawArrays(gl.TRIANGLES, 0, shadowData.length / 10);
          gl.depthMask(true);
          gl.disable(gl.BLEND);
          gl.uniform1f(mesh.uShininess, 26);
          gl.uniform1f(mesh.uSpecStrength, 0.22);
        }

        const aim = buildAimSegments();
        if (aim.length) {
          const lineVerts = [];
          for (let i = 0; i < aim.length; i += 2) {
            const s = aim[i];
            addLine2D(lineVerts, s.x1, s.y1, s.x2, s.y2, 4, [1, 0.18, 0.18, 0.45]);
          }
          gl.useProgram(line.prog);
          gl.bindBuffer(gl.ARRAY_BUFFER, line.vbo);
          gl.enableVertexAttribArray(line.aPos);
          gl.enableVertexAttribArray(line.aCol);
          gl.vertexAttribPointer(line.aPos, 2, gl.FLOAT, false, 24, 0);
          gl.vertexAttribPointer(line.aCol, 4, gl.FLOAT, false, 24, 8);
          gl.disable(gl.DEPTH_TEST);
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          const data = new Float32Array(lineVerts);
          gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, data.length / 6);
          gl.disable(gl.BLEND);
          gl.enable(gl.DEPTH_TEST);
        }
      }

      function renderHud() {
        hud.textContent = state.gameOver ? state.gameOverText : "";
        renderTargetTalks();
      }
      function pickTalkTargets() {
        const alive = [];
        for (let i = 0; i < state.targets.length; i++) {
          if (state.targets[i] && !state.targets[i].dead) alive.push(i);
        }
        if (!alive.length) return [];
        const count = alive.length > 1 && Math.random() < 0.35 ? 2 : 1;
        const shuffledAlive = shuffled(alive);
        return shuffledAlive.slice(0, Math.min(count, shuffledAlive.length));
      }
      function updateTargetTalkActivity(nowSec) {
        if (nowSec < state.targetTalkNextSwitch) return;
        if (!state.targetTalkVisible) {
          state.targetTalkVisible = true;
          state.targetTalkActiveIndices = pickTalkTargets();
          state.targetTalkNextSwitch = nowSec + TARGET_TALK_ON_SEC;
        } else {
          state.targetTalkVisible = false;
          state.targetTalkActiveIndices = [];
          state.targetTalkNextSwitch = nowSec + TARGET_TALK_OFF_SEC;
        }
      }
      function renderTargetTalks() {
        if (!targetTalkLayer) return;
        const nowSec = performance.now() * 0.001;
        updateTargetTalkActivity(nowSec);
        const talks = [];
        const seen = new Set();
        for (let i = 0; i < state.targets.length; i++) {
          const t = state.targets[i];
          if (!t || t.dead) continue;
          if (t.hitTauntUntil <= nowSec) continue;
          const s = worldToScreen(t.x, t.y + t.r + 0.52, t.z);
          if (!s.ok) continue;
          if (s.sx < -120 || s.sx > state.screenW + 120 || s.sy < -80 || s.sy > state.screenH + 80) continue;
          talks.push({ x: s.sx, y: s.sy, text: t.hitTaunt || TARGET_HIT_TAUNT_FALLBACK });
          seen.add(i);
        }
        if (state.targetTalkVisible) {
          for (const i of state.targetTalkActiveIndices) {
            if (seen.has(i)) continue;
            const t = state.targets[i];
            if (!t || t.dead) continue;
            const s = worldToScreen(t.x, t.y + t.r + 0.52, t.z);
            if (!s.ok) continue;
            if (s.sx < -120 || s.sx > state.screenW + 120 || s.sy < -80 || s.sy > state.screenH + 80) continue;
            talks.push({ x: s.sx, y: s.sy, text: t.talk || "有本事打我呀。" });
          }
        }
        if (!talks.length) {
          for (const el of state.targetTalkNodes) el.style.display = "none";
          return;
        }
        while (state.targetTalkNodes.length < talks.length) {
          const el = document.createElement("div");
          el.className = "target-talk";
          targetTalkLayer.appendChild(el);
          state.targetTalkNodes.push(el);
        }
        for (let i = 0; i < state.targetTalkNodes.length; i++) {
          const el = state.targetTalkNodes[i];
          const item = talks[i];
          if (!item) {
            el.style.display = "none";
            continue;
          }
          el.style.display = "";
          el.style.left = `${item.x}px`;
          el.style.top = `${item.y}px`;
          if (el.textContent !== item.text) el.textContent = item.text;
        }
      }

      function loop(now) {
        const dt = Math.min(0.033, (now - state.lastT) / 1000);
        state.lastT = now;
        update(dt, now / 1000);
        renderScene();
        renderHud();
        requestAnimationFrame(loop);
      }

      canvas.addEventListener("pointerdown", onDown, { passive: false });
      canvas.addEventListener("pointermove", onMove, { passive: false });
      window.addEventListener("pointerup", onUp, { passive: false });
      canvas.addEventListener("touchstart", onDown, { passive: false });
      canvas.addEventListener("touchmove", onMove, { passive: false });
      window.addEventListener("touchend", onUp, { passive: false });
      window.addEventListener("resize", () => {
        resize();
        createTargets();
      });
      bgmBtn.addEventListener("click", () => {
        tryStartBgm(true);
      });
      restartBtn.addEventListener("click", () => {
        tryStartBgm(false);
        createTargets();
      });

      if (bgmBtn) bgmBtn.textContent = "开启音乐";
      resize();
      createTargets();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
