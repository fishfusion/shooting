<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
    <title>弹力球枪 3D (WebGL)</title>
    <style>
      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #101722;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        touch-action: none;
      }
      #hud {
        position: fixed;
        left: 12px;
        top: 12px;
        z-index: 30;
        color: #e8efff;
        font: 500 14px/1.35 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
        pointer-events: none;
        white-space: pre-line;
      }
      #announce {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        padding-bottom: 28vh;
        pointer-events: none;
        z-index: 40;
      }
      #announce.show {
        display: flex;
      }
      #announceCard {
        background: rgba(12, 18, 30, 0.58);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 18px;
        padding: 18px 18px 14px;
        max-width: min(86vw, 460px);
        color: #f2f6ff;
        text-align: center;
        box-shadow: 0 14px 36px rgba(0, 0, 0, 0.4);
      }
      #announceCard img {
        width: 120px;
        height: 120px;
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid rgba(255, 255, 255, 0.8);
        margin-bottom: 12px;
      }
      #announceCard p {
        margin: 0;
        font: 600 20px/1.35 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
      }
      #restartBtn {
        margin-top: 14px;
        padding: 8px 22px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.4);
        background: rgba(255, 255, 255, 0.16);
        color: #fff;
        font: 600 18px/1 "Helvetica Neue", "PingFang SC", "Microsoft YaHei", sans-serif;
        pointer-events: auto;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <div id="hud"></div>
    <div id="announce">
      <div id="announceCard">
        <img id="announceImg" alt="winner" />
        <p id="announceText"></p>
        <button id="restartBtn" type="button">确定</button>
      </div>
    </div>
    <script>
      const canvas = document.getElementById("game");
      const hud = document.getElementById("hud");
      const announce = document.getElementById("announce");
      const announceImg = document.getElementById("announceImg");
      const announceText = document.getElementById("announceText");
      const restartBtn = document.getElementById("restartBtn");
      const gl = canvas.getContext("webgl", { antialias: true, alpha: false });
      if (!gl) throw new Error("WebGL not supported");

      const meshVS = `
        attribute vec3 a_pos;
        attribute vec3 a_nrm;
        attribute vec4 a_col;
        uniform mat4 u_viewProj;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        void main() {
          v_pos = a_pos;
          v_nrm = a_nrm;
          v_col = a_col;
          gl_Position = u_viewProj * vec4(a_pos, 1.0);
        }
      `;
      const meshFS = `
        precision mediump float;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        uniform vec3 u_camPos;
        uniform vec3 u_lightDir;
        uniform vec3 u_lightColor;
        uniform float u_lightIntensity;
        uniform vec3 u_ambColor;
        uniform float u_ambIntensity;
        uniform float u_shininess;
        uniform float u_specStrength;
        void main() {
          vec3 n = normalize(v_nrm);
          vec3 l = normalize(-u_lightDir);
          vec3 v = normalize(u_camPos - v_pos);
          vec3 h = normalize(l + v);
          float ndotl = max(dot(n, l), 0.0);
          float ndoth = max(dot(n, h), 0.0);
          float spec = pow(ndoth, u_shininess) * u_specStrength;

          vec3 amb = v_col.rgb * u_ambColor * u_ambIntensity;
          vec3 diff = v_col.rgb * u_lightColor * (ndotl * u_lightIntensity);
          vec3 col = amb + diff + u_lightColor * spec;
          gl_FragColor = vec4(min(col, vec3(1.0)), v_col.a);
        }
      `;
      const texVS = `
        attribute vec3 a_pos;
        attribute vec3 a_nrm;
        attribute vec4 a_col;
        attribute vec2 a_uv;
        uniform mat4 u_viewProj;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        varying vec2 v_uv;
        void main() {
          v_pos = a_pos;
          v_nrm = a_nrm;
          v_col = a_col;
          v_uv = a_uv;
          gl_Position = u_viewProj * vec4(a_pos, 1.0);
        }
      `;
      const texFS = `
        precision mediump float;
        varying vec3 v_pos;
        varying vec3 v_nrm;
        varying vec4 v_col;
        varying vec2 v_uv;
        uniform sampler2D u_tex;
        uniform float u_redTint;
        uniform vec3 u_camPos;
        uniform vec3 u_lightDir;
        uniform vec3 u_lightColor;
        uniform float u_lightIntensity;
        uniform vec3 u_ambColor;
        uniform float u_ambIntensity;
        void main() {
          vec4 tex = texture2D(u_tex, v_uv);
          if (tex.a < 0.01) discard;

          vec3 base = mix(tex.rgb, vec3(1.0, 0.16, 0.16), clamp(u_redTint, 0.0, 0.45));
          base *= v_col.rgb;

          vec3 n = normalize(v_nrm);
          vec3 l = normalize(-u_lightDir);
          vec3 v = normalize(u_camPos - v_pos);
          vec3 h = normalize(l + v);
          float ndotl = max(dot(n, l), 0.0);
          float ndoth = max(dot(n, h), 0.0);
          float spec = pow(ndoth, 28.0) * 0.25;

          vec3 amb = base * u_ambColor * u_ambIntensity;
          vec3 diff = base * u_lightColor * (ndotl * u_lightIntensity);
          vec3 col = amb + diff + u_lightColor * spec;
          gl_FragColor = vec4(min(col, vec3(1.0)), v_col.a);
        }
      `;
      const lineVS = `
        attribute vec2 a_pos;
        attribute vec4 a_col;
        varying vec4 v_col;
        void main() {
          gl_Position = vec4(a_pos, 0.0, 1.0);
          v_col = a_col;
        }
      `;
      const lineFS = `
        precision mediump float;
        varying vec4 v_col;
        void main() {
          gl_FragColor = v_col;
        }
      `;

      function compile(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s));
        return s;
      }
      function makeProgram(vsSrc, fsSrc) {
        const p = gl.createProgram();
        gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
        gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(p));
        return p;
      }

      const meshProg = makeProgram(meshVS, meshFS);
      const texProg = makeProgram(texVS, texFS);
      const lineProg = makeProgram(lineVS, lineFS);

      const mesh = {
        prog: meshProg,
        vbo: gl.createBuffer(),
        aPos: gl.getAttribLocation(meshProg, "a_pos"),
        aNrm: gl.getAttribLocation(meshProg, "a_nrm"),
        aCol: gl.getAttribLocation(meshProg, "a_col"),
        uViewProj: gl.getUniformLocation(meshProg, "u_viewProj"),
        uCamPos: gl.getUniformLocation(meshProg, "u_camPos"),
        uLightDir: gl.getUniformLocation(meshProg, "u_lightDir"),
        uLightColor: gl.getUniformLocation(meshProg, "u_lightColor"),
        uLightIntensity: gl.getUniformLocation(meshProg, "u_lightIntensity"),
        uAmbColor: gl.getUniformLocation(meshProg, "u_ambColor"),
        uAmbIntensity: gl.getUniformLocation(meshProg, "u_ambIntensity"),
        uShininess: gl.getUniformLocation(meshProg, "u_shininess"),
        uSpecStrength: gl.getUniformLocation(meshProg, "u_specStrength"),
      };
      const tex = {
        prog: texProg,
        vbo: gl.createBuffer(),
        aPos: gl.getAttribLocation(texProg, "a_pos"),
        aNrm: gl.getAttribLocation(texProg, "a_nrm"),
        aCol: gl.getAttribLocation(texProg, "a_col"),
        aUv: gl.getAttribLocation(texProg, "a_uv"),
        uViewProj: gl.getUniformLocation(texProg, "u_viewProj"),
        uCamPos: gl.getUniformLocation(texProg, "u_camPos"),
        uLightDir: gl.getUniformLocation(texProg, "u_lightDir"),
        uLightColor: gl.getUniformLocation(texProg, "u_lightColor"),
        uLightIntensity: gl.getUniformLocation(texProg, "u_lightIntensity"),
        uAmbColor: gl.getUniformLocation(texProg, "u_ambColor"),
        uAmbIntensity: gl.getUniformLocation(texProg, "u_ambIntensity"),
        uTex: gl.getUniformLocation(texProg, "u_tex"),
        uRedTint: gl.getUniformLocation(texProg, "u_redTint"),
      };
      const line = {
        prog: lineProg,
        vbo: gl.createBuffer(),
        aPos: gl.getAttribLocation(lineProg, "a_pos"),
        aCol: gl.getAttribLocation(lineProg, "a_col"),
      };

      const world = {
        gravity: -22,
        bounce: 0.64,
        wallBounce: 0.78,
        drag: 0.998,
        groundFriction: 0.93,
        targetSpring: 30,
        targetDamping: 8,
        targetGravity: -5,
      };

      const cam = {
        pos: { x: 0, y: 3.8, z: -16 },
        target: { x: 0, y: 2.6, z: 14 },
        up: { x: 0, y: 1, z: 0 },
        fovY: Math.PI / 4.1,
        near: 0.1,
        far: 120,
      };
      const directionalLight = {
        dir: normalize3(0.9, -1.1, 1.0),
        color: [1.0, 0.96, 0.9],
        intensity: 1.16,
      };
      const ambientLight = {
        color: [0.5, 0.58, 0.7],
        intensity: 0.2,
      };

      const portraitFiles = [
        "Alan.jpg",
        "Ben.jpg",
        "Humphery.jpg",
        "Jessie.jpg",
        "Jill.jpg",
        "LiuYang.jpg",
        "Lynn.jpg",
        "Milton.jpg",
        "NicoleChen.jpg",
        "Sophie.jpg",
        "WuTong.jpg",
        "ZhangLin.jpg",
      ];
      const portraits = portraitFiles.map((file) => {
        const img = new Image();
        img.src = `Assets/${file}`;
        const texObj = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texObj);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        const p = {
          file,
          name: file.replace(".jpg", ""),
          src: `Assets/${file}`,
          tex: texObj,
          loaded: false,
        };
        img.onload = () => {
          gl.bindTexture(gl.TEXTURE_2D, texObj);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
          p.loaded = true;
        };
        return p;
      });

      const DEFAULT_INVITE_API = "/api/invite";
      const ORIGINAL_INVITE = "恭喜你，下周六叫上Leo来我家吃烧烤吧。";
      const PHILOSOPHICAL_SEEDS = [
        "人生像火候，要慢慢入味",
        "关系的温度，来自一起吃饭",
        "答案常在烟火气里",
        "忙碌之外也要留白给朋友",
        "快乐在分享里变大",
      ];

      const state = {
        screenW: 0,
        screenH: 0,
        viewProj: identity4(),
        gun: { x: 0, y: 1.2, z: -6 },
        aim: { yaw: 0, pitch: 0.28, power: 0.35 },
        drag: { active: false, x: 0, y: 0 },
        balls: [],
        fragments: [],
        targets: [],
        score: 0,
        gameOver: false,
        gameOverText: "",
        announceSrc: "",
        announceName: "",
        lastInviteLine: "",
        lastPortraitSet: "",
        lastT: performance.now(),
      };

      function clamp(v, lo, hi) {
        return Math.max(lo, Math.min(hi, v));
      }
      function shuffled(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          const t = a[i];
          a[i] = a[j];
          a[j] = t;
        }
        return a;
      }
      function hasTimePhrase(text) {
        return /(下周[一二三四五六日天末]?|周[一二三四五六日天末]|周末|今晚|明晚|明天|后天|本周|这个周末|下个周末)/.test(text);
      }

      async function generatePhilosophicalInviteLine() {
        const apiUrl = localStorage.getItem("OPENAI_PROXY_URL") || DEFAULT_INVITE_API;
        let lastErr = "";
        for (let attempt = 0; attempt < 5; attempt++) {
          const seed = PHILOSOPHICAL_SEEDS[Math.floor(Math.random() * PHILOSOPHICAL_SEEDS.length)];
          const nonce = `${Date.now().toString(36)}-${attempt}`;
          const prompt = `写一句中文邀请语，必须保留核心意思：你下周末叫上Leo来我家吃烧烤。句子里必须出现一个明确时间点（例如：下周六/周日/周末/明晚）。语气自然，有一点哲理，不要鸡汤，不要解释，只输出一句话。可参考意象：${seed}。避免与这句重复：${state.lastInviteLine || "无"}。随机标记:${nonce}`;
          try {
            const res = await fetch(apiUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ input: prompt, lastInviteLine: state.lastInviteLine || "" }),
            });
            if (!res.ok) {
              const t = await res.text();
              lastErr = `HTTP ${res.status} ${t.slice(0, 140)}`;
              continue;
            }
            const data = await res.json();
            const text = String(data.text || "").trim();
            if (!text) continue;
            let clean = text.replace(/^["'“”]+|["'“”]+$/g, "");
            if (clean === ORIGINAL_INVITE) continue;
            if (/^\s*Leo[，,:：\s]/i.test(clean)) continue;
            if (!/叫上\s*Leo/i.test(clean)) clean = `下周末你叫上Leo，${clean}`;
            if (!/你/.test(clean)) clean = `你${clean}`;
            if (!hasTimePhrase(clean)) clean = `下周六${clean}`;
            if (!/Leo/i.test(clean)) clean = `${clean} 叫上Leo。`;
            if (!/烧烤/.test(clean)) clean = `${clean} 来我家吃烧烤吧。`;
            if (clean === state.lastInviteLine) continue;
            return clean;
          } catch (_err) {
            lastErr = String(_err && _err.message ? _err.message : _err);
            continue;
          }
        }
        return `__ERR_PROXY_FAIL__${lastErr ? ":" + lastErr : ""}`;
      }

      async function showAnnouncement(src) {
        announceImg.src = src;
        announceText.textContent = "正在生成邀请语...";
        announce.classList.add("show");
        const line = await generatePhilosophicalInviteLine();
        if (line.startsWith("__ERR_PROXY_FAIL__")) {
          const detail = line.split(":").slice(1).join(":").trim();
          announceText.textContent = detail ? `生成服务不可用：${detail}` : "生成服务不可用，请检查后端代理配置。";
          return;
        }
        state.lastInviteLine = line;
        announceText.textContent = line;
      }

      function resize() {
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        state.screenW = window.innerWidth;
        state.screenH = window.innerHeight;
        canvas.width = Math.floor(state.screenW * dpr);
        canvas.height = Math.floor(state.screenH * dpr);
        gl.viewport(0, 0, canvas.width, canvas.height);
      }

      function createTargets() {
        const xs = [-5.8, -3.6, -1.5, 1.1, 3.2, 5.5];
        const ys = [2.4, 3.1, 3.8, 2.9, 4.3, 3.4];
        const rs = [1.05, 1.28, 0.98, 1.55, 1.18, 1.12];
        const speed = [0.85, 1.25, 1.0, 1.55, 0.95, 1.35];
        const zs = [14, 18, 22, 26, 30, 34];
        const nearZ = Math.min(...zs);
        const farZ = Math.max(...zs);

        state.gameOver = false;
        state.gameOverText = "";
        state.announceSrc = "";
        state.announceName = "";
        announce.classList.remove("show");
        state.balls = [];
        state.fragments = [];
        state.score = 0;
        state.targets = [];

        let selectedPortraits = shuffled(portraits).slice(0, 6);
        let sig = selectedPortraits.map((p) => p.file).join("|");
        // 避免“点击确定后看起来没换图”：新一局与上一局至少顺序不同。
        if (state.lastPortraitSet && sig === state.lastPortraitSet) {
          for (let i = 0; i < 6; i++) {
            selectedPortraits = shuffled(portraits).slice(0, 6);
            sig = selectedPortraits.map((p) => p.file).join("|");
            if (sig !== state.lastPortraitSet) break;
          }
        }
        state.lastPortraitSet = sig;
        for (let i = 0; i < 6; i++) {
          const z = zs[i];
          const near01 = (farZ - z) / (farZ - nearZ);
          const maxHp = Math.round(70 + near01 * 90);
          state.targets.push({
            baseX: xs[i],
            baseY: ys[i],
            z,
            x: xs[i],
            y: ys[i],
            r: rs[i],
            vx: 0,
            vy: 0,
            mass: 1.1 + rs[i] * 2.0,
            sx: (2.2 + i * 0.45) * (i % 2 ? -1 : 1),
            sy: 1.1 + i * 0.2,
            wx: speed[i] * 2.3,
            wy: speed[i] * 1.8,
            phase: i * 0.8,
            anchorX: xs[i],
            anchorY: ys[i] + rs[i],
            hitTimer: 0,
            maxHp,
            hp: maxHp,
            dead: false,
            vz: 0,
            rotX: 0,
            rotY: 0,
            rotZ: 0,
            avX: 0,
            avY: 0,
            avZ: 0,
            portrait: selectedPortraits[i],
          });
        }
      }

      function pointerPos(e) {
        const p = e.touches ? e.touches[0] : e;
        return { x: p.clientX, y: p.clientY };
      }
      function clampMag(x, y, max) {
        const m = Math.hypot(x, y);
        if (m <= max || m === 0) return { x, y };
        const k = max / m;
        return { x: x * k, y: y * k };
      }
      function isFireLocked() {
        return announce.classList.contains("show");
      }

      function spawnBall(x, y, z, vx, vy, vz) {
        state.balls.push({ x, y, z, vx, vy, vz, r: 0.28, alive: true, stopped: false, hitCd: 0 });
      }

      function spawnBallFragments(ball) {
        const count = 14;
        for (let i = 0; i < count; i++) {
          const dir = normalize3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1);
          const speed = 3 + Math.random() * 6;
          state.fragments.push({
            x: ball.x,
            y: ball.y,
            z: ball.z,
            vx: ball.vx * 0.25 + dir.x * speed,
            vy: ball.vy * 0.2 + Math.abs(dir.y) * speed * 0.9,
            vz: ball.vz * 0.25 + dir.z * speed,
            r: 0.05 + Math.random() * 0.05,
            life: 0.95 + Math.random() * 0.55,
          });
        }
      }

      function onDown(e) {
        if (isFireLocked()) {
          state.drag.active = false;
          return;
        }
        e.preventDefault();
        const p = pointerPos(e);
        state.drag.active = true;
        state.drag.x = p.x;
        state.drag.y = p.y;
      }

      function onMove(e) {
        if (isFireLocked()) return;
        if (!state.drag.active) return;
        e.preventDefault();
        const p = pointerPos(e);
        state.drag.x = p.x;
        state.drag.y = p.y;

        const gunScr = worldToScreen(state.gun.x, state.gun.y, state.gun.z);
        if (!gunScr.ok) return;
        const dx = p.x - gunScr.sx;
        const dy = p.y - gunScr.sy;
        const c = clampMag(dx, dy, 260);
        const mag01 = Math.hypot(c.x, c.y) / 260;

        state.aim.yaw = clamp((-c.x / 260) * 1.0, -0.95, 0.95);
        state.aim.pitch = clamp(0.22 + (-c.y / 260) * 0.9, -0.1, 0.95);
        state.aim.power = clamp(0.2 + mag01 * 0.8, 0.2, 1.0);
      }

      function onUp(e) {
        if (isFireLocked()) {
          state.drag.active = false;
          return;
        }
        if (!state.drag.active) return;
        e.preventDefault();
        state.drag.active = false;

        const shot = getAimShot();
        const pose = getGunPose();
        spawnBall(pose.muzzle.x, pose.muzzle.y, pose.muzzle.z, shot.dir.x * shot.speed, shot.dir.y * shot.speed, shot.dir.z * shot.speed);
      }

      function update(dt, t) {
        for (const target of state.targets) {
          if (!target.dead) {
            target.anchorX = target.baseX + Math.sin(t * target.wx + target.phase) * target.sx;
            target.anchorY = target.baseY + Math.cos(t * target.wy + target.phase * 1.3) * target.sy + target.r;

            const topX = target.x;
            const topY = target.y + target.r;
            const dx = target.anchorX - topX;
            const dy = target.anchorY - topY;
            const ax = world.targetSpring * dx - world.targetDamping * target.vx;
            const ay = world.targetSpring * dy - world.targetDamping * target.vy + world.targetGravity;

            target.vx += ax * dt;
            target.vy += ay * dt;
            target.vx *= 0.995;
            target.vy *= 0.995;
            target.x += target.vx * dt;
            target.y += target.vy * dt;
          } else {
            target.vy += world.gravity * dt;
            target.vx *= 0.996;
            target.vy *= 0.996;
            target.vz *= 0.996;
            target.avX *= 0.992;
            target.avY *= 0.992;
            target.avZ *= 0.992;
            target.x += target.vx * dt;
            target.y += target.vy * dt;
            target.z += target.vz * dt;
            target.rotX += target.avX * dt;
            target.rotY += target.avY * dt;
            target.rotZ += target.avZ * dt;

            const support = targetSupportRadiusY(target);
            if (target.y - support < 0) {
              target.y = support;
              target.vy = Math.abs(target.vy) * 0.35;
              target.vx *= 0.88;
              target.vz *= 0.88;
              target.avX += target.vz * 0.08;
              target.avZ -= target.vx * 0.08;

              const tilt = Math.hypot(target.rotX, target.rotZ);
              if (tilt < 0.95) {
                target.avX += (Math.sign(target.rotX || 1) * 1.1 + (Math.random() - 0.5) * 0.25) * dt * 60;
                target.avZ += (Math.sign(target.rotZ || -1) * 1.1 + (Math.random() - 0.5) * 0.25) * dt * 60;
              }
            }
          }
          target.hitTimer = Math.max(0, target.hitTimer - dt);
        }

        for (const ball of state.balls) {
          if (!ball.alive) continue;
          if (ball.stopped) continue;
          ball.hitCd = Math.max(0, ball.hitCd - dt);
          ball.vy += world.gravity * dt;
          ball.vx *= world.drag;
          ball.vy *= world.drag;
          ball.vz *= world.drag;

          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;
          ball.z += ball.vz * dt;

          if (ball.y - ball.r < 0) {
            ball.y = ball.r;
            ball.vy = Math.abs(ball.vy) * world.bounce;
            ball.vx *= world.groundFriction;
            ball.vz *= world.groundFriction;
            if (Math.abs(ball.vy) < 1.1 && Math.hypot(ball.vx, ball.vz) < 1.0) {
              ball.stopped = true;
              ball.vx = 0;
              ball.vy = 0;
              ball.vz = 0;
            }
          }

          if (ball.x - ball.r < -7) {
            ball.x = -7 + ball.r;
            ball.vx = Math.abs(ball.vx) * world.wallBounce;
          } else if (ball.x + ball.r > 7) {
            ball.x = 7 - ball.r;
            ball.vx = -Math.abs(ball.vx) * world.wallBounce;
          }

          if (ball.z > 35) {
            ball.z = 35;
            ball.vz = -Math.abs(ball.vz) * world.wallBounce;
          }

          for (const target of state.targets) {
            if (target.dead) continue;
            const dx = ball.x - target.x;
            const dy = ball.y - target.y;
            const dz = ball.z - target.z;
            const rr = ball.r + target.r;
            const d2 = dx * dx + dy * dy + dz * dz;
            if (d2 > rr * rr) continue;

            const d = Math.sqrt(d2) || 0.0001;
            const nx = dx / d;
            const ny = dy / d;
            const nz = dz / d;
            const overlap = rr - d;

            ball.x += nx * overlap * 0.7;
            ball.y += ny * overlap * 0.7;
            ball.z += nz * overlap * 0.7;
            target.x -= nx * overlap * 0.3;
            target.y -= ny * overlap * 0.3;

            const rvx = ball.vx - target.vx;
            const rvy = ball.vy - target.vy;
            const rvz = ball.vz;
            const vn = rvx * nx + rvy * ny + rvz * nz;
            if (vn >= 0) continue;

            const restitution = 0.65;
            const invBall = 1.0;
            const invTar = 1.0 / target.mass;
            const j = (-(1 + restitution) * vn) / (invBall + invTar);

            ball.vx += j * nx * invBall;
            ball.vy += j * ny * invBall;
            ball.vz += j * nz * invBall;

            target.vx -= j * nx * invTar;
            target.vy -= j * ny * invTar;

            if (ball.hitCd <= 0 && vn < -3.5) {
              const speed = Math.hypot(ball.vx, ball.vy, ball.vz);
              const impact = Math.max(0, -vn);
              const damage = impact * 3.2 + speed * 0.75;
              target.hp = Math.max(0, target.hp - damage);
              target.hitTimer = 0.25;
              state.score += 1;
              ball.hitCd = 0.08;
              if (target.hp <= 0) {
                state.gameOver = true;
                state.gameOverText = `游戏结束：${target.portrait.name} 被击倒`;
                state.drag.active = false;
                target.dead = true;
                target.vx = target.vx - j * nx * invTar * 0.6;
                target.vy = Math.min(0, target.vy - j * ny * invTar);
                target.vz = -j * nz * invTar;
                target.avX = (0.8 + Math.random() * 1.4) * (Math.random() > 0.5 ? 1 : -1) + target.vz * 0.05;
                target.avY = (Math.random() - 0.5) * 1.2;
                target.avZ = (0.8 + Math.random() * 1.4) * (Math.random() > 0.5 ? 1 : -1) - target.vx * 0.05;
                state.announceSrc = target.portrait.src;
                state.announceName = target.portrait.name;
                showAnnouncement(target.portrait.src);
              }
            }
            // 子弹命中任意目标后碎裂并销毁，防止重复击打。
            spawnBallFragments(ball);
            ball.alive = false;
            break;
          }
        }

        for (const f of state.fragments) {
          f.life -= dt;
          f.vy += world.gravity * dt;
          f.vx *= 0.992;
          f.vy *= 0.992;
          f.vz *= 0.992;
          f.x += f.vx * dt;
          f.y += f.vy * dt;
          f.z += f.vz * dt;

          if (f.y - f.r < 0) {
            f.y = f.r;
            f.vy = Math.abs(f.vy) * 0.34;
            f.vx *= 0.86;
            f.vz *= 0.86;
          }
        }

        state.balls = state.balls.filter((b) => b.stopped || (b.alive && b.z < 42 && b.y > -2));
        state.fragments = state.fragments.filter((f) => f.life > 0 && f.z < 42 && f.y > -2);
      }

      function normalize3(x, y, z) {
        const m = Math.hypot(x, y, z) || 1;
        return { x: x / m, y: y / m, z: z / m };
      }
      function add3(a, b) {
        return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };
      }
      function sub3(a, b) {
        return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
      }
      function mul3(a, s) {
        return { x: a.x * s, y: a.y * s, z: a.z * s };
      }
      function dot3(a, b) {
        return a.x * b.x + a.y * b.y + a.z * b.z;
      }
      function cross3(a, b) {
        return {
          x: a.y * b.z - a.z * b.y,
          y: a.z * b.x - a.x * b.z,
          z: a.x * b.y - a.y * b.x,
        };
      }
      function targetThickness(target) {
        return Math.max(0.26, target.r * 0.42);
      }
      function rotateVecEuler(v, rotX, rotY, rotZ) {
        const cx = Math.cos(rotX), sx = Math.sin(rotX);
        const cy = Math.cos(rotY), sy = Math.sin(rotY);
        const cz = Math.cos(rotZ), sz = Math.sin(rotZ);

        const y1 = v.y * cx - v.z * sx;
        const z1 = v.y * sx + v.z * cx;
        const x1 = v.x;

        const x2 = x1 * cz - y1 * sz;
        const y2 = x1 * sz + y1 * cz;
        const z2 = z1;

        return {
          x: x2 * cy + z2 * sy,
          y: y2,
          z: -x2 * sy + z2 * cy,
        };
      }
      function targetRotateVec(target, v) {
        return rotateVecEuler(v, target.rotX || 0, target.rotY || 0, target.rotZ || 0);
      }
      function targetLocalToWorld(target, lx, ly, lz) {
        const p = targetRotateVec(target, { x: lx, y: ly, z: lz });
        return { x: target.x + p.x, y: target.y + p.y, z: target.z + p.z };
      }
      function targetNormal(target) {
        return normalize3(
          targetRotateVec(target, { x: 0, y: 0, z: 1 }).x,
          targetRotateVec(target, { x: 0, y: 0, z: 1 }).y,
          targetRotateVec(target, { x: 0, y: 0, z: 1 }).z
        );
      }
      function targetSupportRadiusY(target) {
        const n = targetNormal(target);
        const h = targetThickness(target) * 0.5;
        const ring = target.r * Math.sqrt(Math.max(0, 1 - n.y * n.y));
        const cap = h * Math.abs(n.y);
        return ring + cap;
      }

      function identity4() {
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      }
      function mul4(a, b) {
        const o = new Float32Array(16);
        for (let c = 0; c < 4; c++) {
          for (let r = 0; r < 4; r++) {
            o[c * 4 + r] =
              a[0 * 4 + r] * b[c * 4 + 0] +
              a[1 * 4 + r] * b[c * 4 + 1] +
              a[2 * 4 + r] * b[c * 4 + 2] +
              a[3 * 4 + r] * b[c * 4 + 3];
          }
        }
        return o;
      }
      function perspective4(fovY, aspect, near, far) {
        const f = 1.0 / Math.tan(fovY * 0.5);
        const nf = 1.0 / (near - far);
        return new Float32Array([
          f / aspect,
          0,
          0,
          0,
          0,
          f,
          0,
          0,
          0,
          0,
          (far + near) * nf,
          -1,
          0,
          0,
          2 * far * near * nf,
          0,
        ]);
      }
      function lookAt4(eye, target, up) {
        const z = normalize3(eye.x - target.x, eye.y - target.y, eye.z - target.z);
        const x = normalize3(cross3(up, z).x, cross3(up, z).y, cross3(up, z).z);
        const y = cross3(z, x);
        return new Float32Array([
          x.x,
          y.x,
          z.x,
          0,
          x.y,
          y.y,
          z.y,
          0,
          x.z,
          y.z,
          z.z,
          0,
          -dot3(x, eye),
          -dot3(y, eye),
          -dot3(z, eye),
          1,
        ]);
      }
      function mulMat4Vec4(m, v) {
        return {
          x: m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12] * v.w,
          y: m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13] * v.w,
          z: m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14] * v.w,
          w: m[3] * v.x + m[7] * v.y + m[11] * v.z + m[15] * v.w,
        };
      }
      function updateViewProj() {
        const aspect = Math.max(0.1, canvas.width / canvas.height);
        const proj = perspective4(cam.fovY, aspect, cam.near, cam.far);
        const view = lookAt4(cam.pos, cam.target, cam.up);
        state.viewProj = mul4(proj, view);
      }
      function worldToScreen(x, y, z) {
        const c = mulMat4Vec4(state.viewProj, { x, y, z, w: 1 });
        if (c.w <= 0.0001) return { ok: false };
        const ndcX = c.x / c.w;
        const ndcY = c.y / c.w;
        const sx = (ndcX * 0.5 + 0.5) * state.screenW;
        const sy = (1 - (ndcY * 0.5 + 0.5)) * state.screenH;
        return { ok: true, sx, sy, ndcZ: c.z / c.w };
      }

      function getAimShot() {
        const cosP = Math.cos(state.aim.pitch);
        const dir = normalize3(Math.sin(state.aim.yaw) * cosP, Math.sin(state.aim.pitch), Math.cos(state.aim.yaw) * cosP);
        const speed = 34 + state.aim.power * 40;
        return { dir, speed };
      }
      function getGunPose() {
        const { dir } = getAimShot();
        const rightRaw = cross3(dir, { x: 0, y: 1, z: 0 });
        let right = normalize3(rightRaw.x, rightRaw.y, rightRaw.z);
        if (Math.hypot(right.x, right.y, right.z) < 0.0001) right = { x: 1, y: 0, z: 0 };
        const upRaw = cross3(right, dir);
        const up = normalize3(upRaw.x, upRaw.y, upRaw.z);
        const gun = { x: state.gun.x, y: state.gun.y, z: state.gun.z };
        const receiverCenter = add3(gun, add3(mul3(dir, 0.65), mul3(up, 0.08)));
        const barrelCenter = add3(gun, add3(mul3(dir, 1.95), mul3(up, 0.11)));
        const muzzle = add3(barrelCenter, mul3(dir, 1.35));
        return { gun, dir, right, up, receiverCenter, barrelCenter, muzzle };
      }

      function pushMeshVertex(arr, p, n, c) {
        arr.push(p.x, p.y, p.z, n.x, n.y, n.z, c[0], c[1], c[2], c[3] == null ? 1 : c[3]);
      }
      function pushMeshTri(arr, p1, n1, c1, p2, n2, c2, p3, n3, c3) {
        pushMeshVertex(arr, p1, n1, c1);
        pushMeshVertex(arr, p2, n2, c2);
        pushMeshVertex(arr, p3, n3, c3);
      }
      function pushMeshQuad(arr, p1, n1, c1, p2, n2, c2, p3, n3, c3, p4, n4, c4) {
        pushMeshTri(arr, p1, n1, c1, p2, n2, c2, p3, n3, c3);
        pushMeshTri(arr, p1, n1, c1, p3, n3, c3, p4, n4, c4);
      }

      function pushTexVertex(arr, p, n, c, uv) {
        arr.push(p.x, p.y, p.z, n.x, n.y, n.z, c[0], c[1], c[2], c[3] == null ? 1 : c[3], uv[0], uv[1]);
      }
      function pushTexTri(arr, p1, n1, c1, uv1, p2, n2, c2, uv2, p3, n3, c3, uv3) {
        pushTexVertex(arr, p1, n1, c1, uv1);
        pushTexVertex(arr, p2, n2, c2, uv2);
        pushTexVertex(arr, p3, n3, c3, uv3);
      }

      function addPrismMesh(arr, center, axisDir, length, width, height, col) {
        const axis = normalize3(axisDir.x, axisDir.y, axisDir.z);
        let refUp = { x: 0, y: 1, z: 0 };
        if (Math.abs(dot3(axis, refUp)) > 0.93) refUp = { x: 1, y: 0, z: 0 };
        const right = normalize3(cross3(axis, refUp).x, cross3(axis, refUp).y, cross3(axis, refUp).z);
        const up = normalize3(cross3(right, axis).x, cross3(right, axis).y, cross3(right, axis).z);

        const hf = length * 0.5;
        const hw = width * 0.5;
        const hh = height * 0.5;
        const p = (f, rw, uh) => add3(add3(center, mul3(axis, f * hf)), add3(mul3(right, rw * hw), mul3(up, uh * hh)));

        const F1 = p(1, -1, -1), F2 = p(1, 1, -1), F3 = p(1, 1, 1), F4 = p(1, -1, 1);
        const B1 = p(-1, -1, -1), B2 = p(-1, 1, -1), B3 = p(-1, 1, 1), B4 = p(-1, -1, 1);

        pushMeshQuad(arr, F1, axis, col, F2, axis, col, F3, axis, col, F4, axis, col);
        pushMeshQuad(arr, B2, mul3(axis, -1), col, B1, mul3(axis, -1), col, B4, mul3(axis, -1), col, B3, mul3(axis, -1), col);
        pushMeshQuad(arr, B1, mul3(right, -1), col, F1, mul3(right, -1), col, F4, mul3(right, -1), col, B4, mul3(right, -1), col);
        pushMeshQuad(arr, F2, right, col, B2, right, col, B3, right, col, F3, right, col);
        pushMeshQuad(arr, B4, up, col, F4, up, col, F3, up, col, B3, up, col);
        pushMeshQuad(arr, B1, mul3(up, -1), col, B2, mul3(up, -1), col, F2, mul3(up, -1), col, F1, mul3(up, -1), col);
      }

      function addSphereMesh(arr, c, r, col, stacks = 10, slices = 16) {
        for (let i = 0; i < stacks; i++) {
          const v0 = i / stacks;
          const v1 = (i + 1) / stacks;
          const t0 = v0 * Math.PI;
          const t1 = v1 * Math.PI;
          for (let j = 0; j < slices; j++) {
            const u0 = (j / slices) * Math.PI * 2;
            const u1 = ((j + 1) / slices) * Math.PI * 2;
            const n00 = { x: Math.sin(t0) * Math.cos(u0), y: Math.cos(t0), z: Math.sin(t0) * Math.sin(u0) };
            const n10 = { x: Math.sin(t1) * Math.cos(u0), y: Math.cos(t1), z: Math.sin(t1) * Math.sin(u0) };
            const n11 = { x: Math.sin(t1) * Math.cos(u1), y: Math.cos(t1), z: Math.sin(t1) * Math.sin(u1) };
            const n01 = { x: Math.sin(t0) * Math.cos(u1), y: Math.cos(t0), z: Math.sin(t0) * Math.sin(u1) };
            const p00 = add3(c, mul3(n00, r));
            const p10 = add3(c, mul3(n10, r));
            const p11 = add3(c, mul3(n11, r));
            const p01 = add3(c, mul3(n01, r));
            pushMeshTri(arr, p00, n00, col, p10, n10, col, p11, n11, col);
            pushMeshTri(arr, p00, n00, col, p11, n11, col, p01, n01, col);
          }
        }
      }

      function addGround(meshArr) {
        const xMin = -9;
        const xMax = 9;
        const zNear = -3;
        const zFar = 35;
        const base = [0.68, 0.76, 0.9, 1.0];

        pushMeshQuad(
          meshArr,
          { x: xMin, y: 0, z: zNear },
          { x: 0, y: 1, z: 0 },
          base,
          { x: xMax, y: 0, z: zNear },
          { x: 0, y: 1, z: 0 },
          base,
          { x: xMax, y: 0, z: zFar },
          { x: 0, y: 1, z: 0 },
          base,
          { x: xMin, y: 0, z: zFar },
          { x: 0, y: 1, z: 0 },
          base
        );

        const lineCol = [0.75, 0.84, 0.96, 0.92];
        for (let z = 2; z <= 34; z += 2) {
          addGroundLine(meshArr, { x: -8, y: 0.015, z }, { x: 8, y: 0.015, z }, 0.025, lineCol);
        }
        for (let x = -8; x <= 8; x += 1.5) {
          addGroundLine(meshArr, { x, y: 0.015, z: 2 }, { x, y: 0.015, z: 34 }, 0.025, lineCol);
        }
      }
      function addGroundLine(arr, a, b, w, col) {
        const d = sub3(b, a);
        const len = Math.hypot(d.x, d.y, d.z) || 1;
        const dir = { x: d.x / len, y: d.y / len, z: d.z / len };
        const right = normalize3(-dir.z, 0, dir.x);
        const off = mul3(right, w * 0.5);
        const p1 = add3(a, off);
        const p2 = add3(b, off);
        const p3 = sub3(b, off);
        const p4 = sub3(a, off);
        const n = { x: 0, y: 1, z: 0 };
        pushMeshQuad(arr, p1, n, col, p2, n, col, p3, n, col, p4, n, col);
      }

      function addTargetShadow(arr, target) {
        const ldir = normalize3(directionalLight.dir.x, directionalLight.dir.y, directionalLight.dir.z);
        const t = target.y / Math.max(0.0001, -ldir.y);
        const c = { x: target.x + ldir.x * t, y: 0.02, z: target.z + ldir.z * t };
        const shadowR = target.r * (1.2 + Math.max(0.6, target.y) * 0.22);
        const seg = 22;
        const col = [0.1, 0.11, 0.14, 0.24];
        for (let i = 0; i < seg; i++) {
          const a0 = (i / seg) * Math.PI * 2;
          const a1 = ((i + 1) / seg) * Math.PI * 2;
          const p0 = { x: c.x + Math.cos(a0) * shadowR, y: c.y, z: c.z + Math.sin(a0) * shadowR };
          const p1 = { x: c.x + Math.cos(a1) * shadowR, y: c.y, z: c.z + Math.sin(a1) * shadowR };
          const n = { x: 0, y: 1, z: 0 };
          pushMeshTri(arr, c, n, col, p0, n, col, p1, n, col);
        }
      }

      function addTargetGeometry(meshArr, target) {
        const seg = 36;
        const thickness = targetThickness(target);
        const half = thickness * 0.5;
        const hp01 = target.maxHp > 0 ? target.hp / target.maxHp : 0;

        const bodyCol = target.hitTimer > 0 ? [0.95, 0.45, 0.34, 1] : [0.72, 0.46 + hp01 * 0.14, 0.38 + hp01 * 0.1, 1];
        const sideCol = [bodyCol[0] * 0.64, bodyCol[1] * 0.64, bodyCol[2] * 0.64, 1];
        const backCol = [bodyCol[0] * 0.52, bodyCol[1] * 0.52, bodyCol[2] * 0.52, 1];

        for (let i = 0; i < seg; i++) {
          const a0 = (i / seg) * Math.PI * 2;
          const a1 = ((i + 1) / seg) * Math.PI * 2;
          const nx0 = Math.cos(a0);
          const ny0 = Math.sin(a0);
          const nx1 = Math.cos(a1);
          const ny1 = Math.sin(a1);

          const pF0 = targetLocalToWorld(target, nx0 * target.r, ny0 * target.r, -half);
          const pF1 = targetLocalToWorld(target, nx1 * target.r, ny1 * target.r, -half);
          const pB0 = targetLocalToWorld(target, nx0 * target.r, ny0 * target.r, half);
          const pB1 = targetLocalToWorld(target, nx1 * target.r, ny1 * target.r, half);
          const n0 = normalize3(
            targetRotateVec(target, { x: nx0, y: ny0, z: 0 }).x,
            targetRotateVec(target, { x: nx0, y: ny0, z: 0 }).y,
            targetRotateVec(target, { x: nx0, y: ny0, z: 0 }).z
          );
          const n1 = normalize3(
            targetRotateVec(target, { x: nx1, y: ny1, z: 0 }).x,
            targetRotateVec(target, { x: nx1, y: ny1, z: 0 }).y,
            targetRotateVec(target, { x: nx1, y: ny1, z: 0 }).z
          );
          pushMeshQuad(meshArr, pF0, n0, sideCol, pB0, n0, sideCol, pB1, n1, sideCol, pF1, n1, sideCol);

          const cBack = targetLocalToWorld(target, 0, 0, half);
          const nBack = normalize3(
            targetRotateVec(target, { x: 0, y: 0, z: 1 }).x,
            targetRotateVec(target, { x: 0, y: 0, z: 1 }).y,
            targetRotateVec(target, { x: 0, y: 0, z: 1 }).z
          );
          pushMeshTri(meshArr, cBack, nBack, backCol, pB1, nBack, backCol, pB0, nBack, backCol);
        }

        const rimCol = [0.96, 0.96, 0.96, 1];
        const rimOuter = target.r * 1.05;
        const rimInner = target.r * 0.985;
        const nRim = normalize3(
          targetRotateVec(target, { x: 0, y: 0, z: -1 }).x,
          targetRotateVec(target, { x: 0, y: 0, z: -1 }).y,
          targetRotateVec(target, { x: 0, y: 0, z: -1 }).z
        );
        for (let i = 0; i < seg; i++) {
          const a0 = (i / seg) * Math.PI * 2;
          const a1 = ((i + 1) / seg) * Math.PI * 2;
          const o0 = targetLocalToWorld(target, Math.cos(a0) * rimOuter, Math.sin(a0) * rimOuter, -half - 0.002);
          const o1 = targetLocalToWorld(target, Math.cos(a1) * rimOuter, Math.sin(a1) * rimOuter, -half - 0.002);
          const i0 = targetLocalToWorld(target, Math.cos(a0) * rimInner, Math.sin(a0) * rimInner, -half - 0.002);
          const i1 = targetLocalToWorld(target, Math.cos(a1) * rimInner, Math.sin(a1) * rimInner, -half - 0.002);
          pushMeshQuad(meshArr, o0, nRim, rimCol, o1, nRim, rimCol, i1, nRim, rimCol, i0, nRim, rimCol);
        }
      }

      function addGun(meshArr) {
        const pose = getGunPose();
        const dir = pose.dir;
        const up = pose.up;
        const gun = pose.gun;
        const receiverCenter = pose.receiverCenter;
        const barrelCenter = pose.barrelCenter;
        const gripAxis = normalize3(dir.x * 0.2, -0.95, dir.z * 0.2);
        const gripCenter = add3(gun, add3(mul3(dir, -0.2), mul3(up, -0.68)));

        addPrismMesh(meshArr, receiverCenter, dir, 1.6, 0.52, 0.36, [0.24, 0.3, 0.4, 1]);
        addPrismMesh(meshArr, barrelCenter, dir, 2.4, 0.26, 0.22, [0.2, 0.25, 0.34, 1]);
        addPrismMesh(meshArr, gripCenter, gripAxis, 1.25, 0.34, 0.52, [0.36, 0.24, 0.17, 1]);

        const guardCenter = add3(gun, add3(mul3(dir, 0.1), mul3(up, -0.2)));
        addPrismMesh(meshArr, guardCenter, dir, 0.56, 0.2, 0.12, [0.15, 0.19, 0.26, 1]);

        const sightBack = add3(receiverCenter, add3(mul3(dir, 0.5), mul3(up, 0.28)));
        const sightFront = add3(barrelCenter, add3(mul3(dir, 1.0), mul3(up, 0.25)));
        addPrismMesh(meshArr, sightBack, up, 0.16, 0.08, 0.12, [0.28, 0.34, 0.45, 1]);
        addPrismMesh(meshArr, sightFront, up, 0.2, 0.08, 0.16, [0.3, 0.36, 0.48, 1]);
      }

      function toClipX(x) {
        return (x / state.screenW) * 2 - 1;
      }
      function toClipY(y) {
        return 1 - (y / state.screenH) * 2;
      }
      function addLine2D(arr, x1, y1, x2, y2, w, c) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const m = Math.hypot(dx, dy) || 1;
        const nx = (-dy / m) * w * 0.5;
        const ny = (dx / m) * w * 0.5;
        const p1 = [toClipX(x1 + nx), toClipY(y1 + ny)];
        const p2 = [toClipX(x2 + nx), toClipY(y2 + ny)];
        const p3 = [toClipX(x2 - nx), toClipY(y2 - ny)];
        const p4 = [toClipX(x1 - nx), toClipY(y1 - ny)];
        pushLineTri(arr, p1, c, p2, c, p3, c);
        pushLineTri(arr, p1, c, p3, c, p4, c);
      }
      function pushLineTri(arr, p1, c1, p2, c2, p3, c3) {
        arr.push(p1[0], p1[1], c1[0], c1[1], c1[2], c1[3]);
        arr.push(p2[0], p2[1], c2[0], c2[1], c2[2], c2[3]);
        arr.push(p3[0], p3[1], c3[0], c3[1], c3[2], c3[3]);
      }

      function buildAimSegments() {
        if (!state.drag.active) return [];
        const shot = getAimShot();
        const pose = getGunPose();
        let p = { x: pose.muzzle.x, y: pose.muzzle.y, z: pose.muzzle.z };
        let v3 = { x: shot.dir.x * shot.speed, y: shot.dir.y * shot.speed, z: shot.dir.z * shot.speed };
        const dt = 0.07;
        const steps = 46;
        const out = [];
        for (let i = 0; i < steps; i++) {
          const prev = { x: p.x, y: p.y, z: p.z };
          v3.y += world.gravity * dt;
          v3.x *= world.drag;
          v3.y *= world.drag;
          v3.z *= world.drag;
          p.x += v3.x * dt;
          p.y += v3.y * dt;
          p.z += v3.z * dt;
          if (p.y < 0) p.y = 0;
          const s0 = worldToScreen(prev.x, prev.y, prev.z);
          const s1 = worldToScreen(p.x, p.y, p.z);
          if (s0.ok && s1.ok) out.push({ x1: s0.sx, y1: s0.sy, x2: s1.sx, y2: s1.sy });
          if (p.y <= 0) break;
        }
        return out;
      }

      function renderScene() {
        updateViewProj();

        const meshVerts = [];
        const shadowVerts = [];

        addGround(meshVerts);

        for (const t of state.targets) {
          addTargetShadow(shadowVerts, t);
        }

        for (const b of state.balls) {
          if (!b.alive) continue;
          addSphereMesh(meshVerts, { x: b.x, y: b.y, z: b.z }, b.r, [0.18, 0.22, 0.3, 1], 10, 16);
        }
        for (const f of state.fragments) {
          addSphereMesh(meshVerts, { x: f.x, y: f.y, z: f.z }, f.r, [0.2, 0.22, 0.28, 1], 7, 10);
        }

        for (const t of state.targets) {
          if (!t.dead) {
            addTargetGeometry(meshVerts, t);
          } else {
            addTargetGeometry(meshVerts, t);
          }
        }

        addGun(meshVerts);

        gl.clearColor(0.88, 0.92, 1.0, 1.0);
        gl.clearDepth(1);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.disable(gl.CULL_FACE);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        gl.useProgram(mesh.prog);
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
        gl.enableVertexAttribArray(mesh.aPos);
        gl.enableVertexAttribArray(mesh.aNrm);
        gl.enableVertexAttribArray(mesh.aCol);
        gl.vertexAttribPointer(mesh.aPos, 3, gl.FLOAT, false, 40, 0);
        gl.vertexAttribPointer(mesh.aNrm, 3, gl.FLOAT, false, 40, 12);
        gl.vertexAttribPointer(mesh.aCol, 4, gl.FLOAT, false, 40, 24);

        gl.uniformMatrix4fv(mesh.uViewProj, false, state.viewProj);
        gl.uniform3f(mesh.uCamPos, cam.pos.x, cam.pos.y, cam.pos.z);
        gl.uniform3f(mesh.uLightDir, directionalLight.dir.x, directionalLight.dir.y, directionalLight.dir.z);
        gl.uniform3f(mesh.uLightColor, directionalLight.color[0], directionalLight.color[1], directionalLight.color[2]);
        gl.uniform1f(mesh.uLightIntensity, directionalLight.intensity);
        gl.uniform3f(mesh.uAmbColor, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);
        gl.uniform1f(mesh.uAmbIntensity, ambientLight.intensity);
        gl.uniform1f(mesh.uShininess, 26);
        gl.uniform1f(mesh.uSpecStrength, 0.22);

        const meshData = new Float32Array(meshVerts);
        gl.bufferData(gl.ARRAY_BUFFER, meshData, gl.DYNAMIC_DRAW);
        gl.disable(gl.BLEND);
        gl.depthMask(true);
        gl.drawArrays(gl.TRIANGLES, 0, meshData.length / 10);

        const texTargets = state.targets.filter((t) => t.portrait && t.portrait.loaded);
        gl.useProgram(tex.prog);
        gl.bindBuffer(gl.ARRAY_BUFFER, tex.vbo);
        gl.enableVertexAttribArray(tex.aPos);
        gl.enableVertexAttribArray(tex.aNrm);
        gl.enableVertexAttribArray(tex.aCol);
        gl.enableVertexAttribArray(tex.aUv);
        gl.vertexAttribPointer(tex.aPos, 3, gl.FLOAT, false, 48, 0);
        gl.vertexAttribPointer(tex.aNrm, 3, gl.FLOAT, false, 48, 12);
        gl.vertexAttribPointer(tex.aCol, 4, gl.FLOAT, false, 48, 24);
        gl.vertexAttribPointer(tex.aUv, 2, gl.FLOAT, false, 48, 40);

        gl.uniformMatrix4fv(tex.uViewProj, false, state.viewProj);
        gl.uniform3f(tex.uCamPos, cam.pos.x, cam.pos.y, cam.pos.z);
        gl.uniform3f(tex.uLightDir, directionalLight.dir.x, directionalLight.dir.y, directionalLight.dir.z);
        gl.uniform3f(tex.uLightColor, directionalLight.color[0], directionalLight.color[1], directionalLight.color[2]);
        gl.uniform1f(tex.uLightIntensity, directionalLight.intensity);
        gl.uniform3f(tex.uAmbColor, ambientLight.color[0], ambientLight.color[1], ambientLight.color[2]);
        gl.uniform1f(tex.uAmbIntensity, ambientLight.intensity);
        gl.uniform1i(tex.uTex, 0);

        for (const t of texTargets) {
          const seg = 36;
          const thickness = targetThickness(t);
          const half = thickness * 0.5;
          const n = normalize3(
            targetRotateVec(t, { x: 0, y: 0, z: -1 }).x,
            targetRotateVec(t, { x: 0, y: 0, z: -1 }).y,
            targetRotateVec(t, { x: 0, y: 0, z: -1 }).z
          );
          const verts = [];
          for (let i = 0; i < seg; i++) {
            const a0 = (i / seg) * Math.PI * 2;
            const a1 = ((i + 1) / seg) * Math.PI * 2;
            const x0 = Math.cos(a0);
            const y0 = Math.sin(a0);
            const x1 = Math.cos(a1);
            const y1 = Math.sin(a1);
            const c = targetLocalToWorld(t, 0, 0, -half - 0.001);
            const p0 = targetLocalToWorld(t, x0 * t.r, y0 * t.r, -half - 0.001);
            const p1 = targetLocalToWorld(t, x1 * t.r, y1 * t.r, -half - 0.001);
            pushTexTri(verts, c, n, [1, 1, 1, 1], [0.5, 0.5], p0, n, [1, 1, 1, 1], [0.5 + x0 * 0.5, 0.5 + y0 * 0.5], p1, n, [1, 1, 1, 1], [0.5 + x1 * 0.5, 0.5 + y1 * 0.5]);
          }
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, t.portrait.tex);
          const hp01 = t.maxHp > 0 ? t.hp / t.maxHp : 0;
          gl.uniform1f(tex.uRedTint, clamp((1 - hp01) * 0.35, 0, 0.35));
          const data = new Float32Array(verts);
          gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, data.length / 12);
        }

        gl.useProgram(mesh.prog);
        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
        gl.enableVertexAttribArray(mesh.aPos);
        gl.enableVertexAttribArray(mesh.aNrm);
        gl.enableVertexAttribArray(mesh.aCol);
        gl.vertexAttribPointer(mesh.aPos, 3, gl.FLOAT, false, 40, 0);
        gl.vertexAttribPointer(mesh.aNrm, 3, gl.FLOAT, false, 40, 12);
        gl.vertexAttribPointer(mesh.aCol, 4, gl.FLOAT, false, 40, 24);

        if (shadowVerts.length) {
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          gl.depthMask(false);
          const shadowData = new Float32Array(shadowVerts);
          gl.bufferData(gl.ARRAY_BUFFER, shadowData, gl.DYNAMIC_DRAW);
          gl.uniform1f(mesh.uShininess, 8);
          gl.uniform1f(mesh.uSpecStrength, 0.03);
          gl.drawArrays(gl.TRIANGLES, 0, shadowData.length / 10);
          gl.depthMask(true);
          gl.disable(gl.BLEND);
          gl.uniform1f(mesh.uShininess, 26);
          gl.uniform1f(mesh.uSpecStrength, 0.22);
        }

        const aim = buildAimSegments();
        if (aim.length) {
          const lineVerts = [];
          for (let i = 0; i < aim.length; i += 2) {
            const s = aim[i];
            addLine2D(lineVerts, s.x1, s.y1, s.x2, s.y2, 4, [1, 0.18, 0.18, 0.45]);
          }
          gl.useProgram(line.prog);
          gl.bindBuffer(gl.ARRAY_BUFFER, line.vbo);
          gl.enableVertexAttribArray(line.aPos);
          gl.enableVertexAttribArray(line.aCol);
          gl.vertexAttribPointer(line.aPos, 2, gl.FLOAT, false, 24, 0);
          gl.vertexAttribPointer(line.aCol, 4, gl.FLOAT, false, 24, 8);
          gl.disable(gl.DEPTH_TEST);
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          const data = new Float32Array(lineVerts);
          gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
          gl.drawArrays(gl.TRIANGLES, 0, data.length / 6);
          gl.disable(gl.BLEND);
          gl.enable(gl.DEPTH_TEST);
        }
      }

      function renderHud() {
        const hpText = state.targets.map((t, i) => `${i + 1}:${Math.ceil(t.hp)}/${t.maxHp}`).join("  ");
        hud.textContent = `力度已增强\n圆盘血量 ${hpText}${state.gameOver ? `\n${state.gameOverText}` : ""}`;
      }

      function loop(now) {
        const dt = Math.min(0.033, (now - state.lastT) / 1000);
        state.lastT = now;
        update(dt, now / 1000);
        renderScene();
        renderHud();
        requestAnimationFrame(loop);
      }

      canvas.addEventListener("pointerdown", onDown, { passive: false });
      canvas.addEventListener("pointermove", onMove, { passive: false });
      window.addEventListener("pointerup", onUp, { passive: false });
      canvas.addEventListener("touchstart", onDown, { passive: false });
      canvas.addEventListener("touchmove", onMove, { passive: false });
      window.addEventListener("touchend", onUp, { passive: false });
      window.addEventListener("resize", () => {
        resize();
        createTargets();
      });
      restartBtn.addEventListener("click", () => {
        createTargets();
      });

      resize();
      createTargets();
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
